/* Automatically generated by p4c-ebpf from simple_switch.p4 on Mon May  8 15:22:03 2023
 */
#include "ebpf_kernel.h"

#include <stdbool.h>
#include <linux/if_ether.h>
#include "psa.h"

#define EBPF_MASK(t, w) ((((t)(1)) << (w)) - (t)1)
#define BYTES(w) ((w) / 8)
#define write_partial(a, w, s, v) do { *((u8*)a) = ((*((u8*)a)) & ~(EBPF_MASK(u8, w) << s)) | (v << s) ; } while (0)
#define write_byte(base, offset, v) do { *(u8*)((base) + (offset)) = (v); } while (0)
#define bpf_trace_message(fmt, ...)


#define CLONE_MAX_PORTS 64
#define CLONE_MAX_INSTANCES 1
#define CLONE_MAX_CLONES (CLONE_MAX_PORTS * CLONE_MAX_INSTANCES)
#define CLONE_MAX_SESSIONS 1024

#ifndef PSA_PORT_RECIRCULATE
#define PSA_PORT_RECIRCULATE 0
#endif
#define P4C_PSA_PORT_RECIRCULATE 0xfffffffa

struct internal_metadata {
    __u16 pkt_ether_type;
} __attribute__((aligned(4)));

struct list_key_t {
    __u32 port;
    __u16 instance;
};
typedef struct list_key_t elem_t;

struct element {
    struct clone_session_entry entry;
    elem_t next_id;
} __attribute__((aligned(4)));


struct metadata {
    u8 isSource; /* bool */
    u8 isTransit; /* bool */
    u8 isSink; /* bit<1> */
    u8 isClone; /* bool */
    u8 intSink; /* bit<1> */
    u32 ingress_port; /* PortId_t */
    u32 node_id; /* NodeID */
    u64 ingress_timestamp; /* bit<64> */
    u16 new_bytes; /* bit<16> */
    u8 new_words; /* bit<8> */
    u8 int_shim_len; /* bit<8> */
};
struct empty_t {
};
struct ethernet_t {
    u64 dstAddr; /* EthernetAddress */
    u64 srcAddr; /* EthernetAddress */
    u16 etherType; /* bit<16> */
    u8 ebpf_valid;
};
struct ipv4_t {
    u8 version; /* bit<4> */
    u8 ihl; /* bit<4> */
    u8 dscp; /* bit<6> */
    u8 ecn; /* bit<2> */
    u16 totallen; /* bit<16> */
    u16 identification; /* bit<16> */
    u8 flags; /* bit<3> */
    u16 fragOffset; /* bit<13> */
    u8 ttl; /* bit<8> */
    u8 protocol; /* bit<8> */
    u16 hdrChecksum; /* bit<16> */
    u32 srcAddr; /* bit<32> */
    u32 dstAddr; /* bit<32> */
    u8 ebpf_valid;
};
struct udp_t {
    u16 srcPort; /* bit<16> */
    u16 dstPort; /* bit<16> */
    u16 length_; /* bit<16> */
    u16 checksum; /* bit<16> */
    u8 ebpf_valid;
};
struct int_shim_hdr_t {
    u8 int_type; /* bit<4> */
    u8 next_protocol; /* bit<2> */
    u8 reserved; /* bit<2> */
    u8 int_total_length; /* bit<8> */
    u16 udp_ip_dscp; /* bit<16> */
    u8 ebpf_valid;
};
struct int_md_hdr_t {
    u8 ver; /* bit<4> */
    u8 d; /* bit<1> */
    u8 e; /* bit<1> */
    u8 m; /* bit<1> */
    u16 reserved; /* bit<12> */
    u8 hop_metadata_length; /* bit<5> */
    u8 remaining_hop_count; /* bit<8> */
    u8 instruction_bitmap_0003; /* bit<4> */
    u8 instruction_bitmap_0407; /* bit<4> */
    u8 instruction_bitmap_0811; /* bit<4> */
    u8 instruction_bitmap_1215; /* bit<4> */
    u16 domain_specific_id; /* bit<16> */
    u16 domain_specific_instruction; /* bit<16> */
    u16 domains_specific_flags; /* bit<16> */
    u8 ebpf_valid;
};
struct int_node_id_t {
    u32 node_id; /* NodeID */
    u8 ebpf_valid;
};
struct int_l1_interfaces_t {
    u16 ingress_id; /* bit<16> */
    u16 egress_id; /* bit<16> */
    u8 ebpf_valid;
};
struct int_hop_latency_t {
    u32 hop_latency; /* HopLatency */
    u8 ebpf_valid;
};
struct int_queue_info_t {
    u8 queue_id; /* QueueID */
    u32 queue_occupancy; /* QueueOccupancy */
    u8 ebpf_valid;
};
struct int_ingress_timestamp_t {
    u64 ingress_timestamp; /* Timestamp */
    u8 ebpf_valid;
};
struct int_egress_timestamp_t {
    u64 egress_timestamp; /* Timestamp */
    u8 ebpf_valid;
};
struct int_l2_interfaces_t {
    u32 ingress_id; /* L2InterfaceID */
    u32 egress_id; /* L2InterfaceID */
    u8 ebpf_valid;
};
struct int_egress_tx_t {
    u32 egress_tx_utilization; /* InterfaceTxUtilization */
    u8 ebpf_valid;
};
struct int_buffer_info_t {
    u8 buffer_id; /* BufferID */
    u32 buffer_occupancy; /* BufferOccupancy */
    u8 ebpf_valid;
};
struct int_checksum_t {
    u32 checksum; /* ChecksumComplement */
    u8 ebpf_valid;
};
struct int_metadata_stack_t {
    u8 metadata_stack[16]; /* bit<128> */
    u8 ebpf_valid;
};
struct umeta_t {
    u8 isINTSink; /* bit<1> */
    u32 ingress_port; /* bit<32> */
    u64 ingress_timestamp; /* bit<64> */
    u8 padding; /* bit<7> */
    u8 ebpf_valid;
};
struct headers {
    struct umeta_t umeta; /* umeta_t */
    struct ethernet_t ethernet; /* ethernet_t */
    struct ipv4_t ipv4; /* ipv4_t */
    struct udp_t udp; /* udp_t */
    struct int_shim_hdr_t int_shim; /* int_shim_hdr_t */
    struct int_md_hdr_t int_md; /* int_md_hdr_t */
    struct int_metadata_stack_t int_data; /* int_metadata_stack_t */
    struct int_node_id_t int_node_id; /* int_node_id_t */
    struct int_l1_interfaces_t int_l1_interfaces; /* int_l1_interfaces_t */
    struct int_hop_latency_t int_hop_latency; /* int_hop_latency_t */
    struct int_queue_info_t int_queue_info; /* int_queue_info_t */
    struct int_ingress_timestamp_t int_ingress_timestamp; /* int_ingress_timestamp_t */
    struct int_egress_timestamp_t int_egress_timestamp; /* int_egress_timestamp_t */
    struct int_l2_interfaces_t int_l2_interfaces; /* int_l2_interfaces_t */
    struct int_egress_tx_t int_egress_tx; /* int_egress_tx_t */
    struct int_buffer_info_t int_buffer_info; /* int_buffer_info_t */
    struct int_checksum_t int_checksum; /* int_checksum_t */
};
struct ingress_tbl_fwd_key {
    u32 field0; /* hdr.ipv4.dstAddr */
} __attribute__((aligned(4)));
#define INGRESS_TBL_FWD_ACT_INGRESS_DO_FORWARD 1
struct ingress_tbl_fwd_value {
    unsigned int action;
    union {
        struct {
        } _NoAction;
        struct {
            u32 egress_port;
            u64 srcAddr;
            u64 dstAddr;
        } ingress_do_forward;
    } u;
    struct {
        u32 packets;
    } ingress_forward_counter;
};
struct ingress_tbl_role_sink_key {
    u32 field0; /* hdr.ipv4.dstAddr */
    u16 field1; /* hdr.udp.srcPort */
    u32 field2; /* ostd.egress_port */
} __attribute__((aligned(4)));
#define INGRESS_TBL_ROLE_SINK_ACT_INGRESS_SET_SINK 1
struct ingress_tbl_role_sink_value {
    unsigned int action;
    union {
        struct {
        } _NoAction;
        struct {
            u16 csi;
            u32 port;
        } ingress_set_sink;
    } u;
    struct {
        u32 packets;
    } ingress_int_sink_counter;
};
struct ingress_tbl_role_source_key {
    u32 field0; /* hdr.ipv4.srcAddr */
    u16 field1; /* hdr.udp.srcPort */
    u32 field2; /* istd.ingress_port */
} __attribute__((aligned(4)));
#define INGRESS_TBL_ROLE_SOURCE_ACT_INGRESS_SET_SOURCE 1
struct ingress_tbl_role_source_value {
    unsigned int action;
    union {
        struct {
        } _NoAction;
        struct {
            u8 mdLen;
            u8 remHops;
            u8 iBit0;
            u8 iBit1;
            u8 iBit2;
            u8 iBit3;
        } ingress_set_source;
    } u;
    struct {
        u32 packets;
    } ingress_int_src_counter;
};
struct egress_InsertMetadata_tb_int_insert_key {
    u8 field0; /*     hdr.int_shim.ebpf_valid */
} __attribute__((aligned(4)));
#define EGRESS_INSERTMETADATA_TB_INT_INSERT_ACT_EGRESS_INSERTMETADATA_INIT_METADATA 1
struct egress_InsertMetadata_tb_int_insert_value {
    unsigned int action;
    union {
        struct {
        } _NoAction;
        struct {
            u32 node_id;
        } egress_InsertMetadata_init_metadata;
    } u;
    struct {
        u32 packets;
    } egress_InsertMetadata_insert_counter;
};
struct egress_InsertMetadata_tb_int_inst_0003_key {
    u8 field0; /* hdr.int_md.instruction_bitmap_0003 */
} __attribute__((aligned(4)));
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I0 1
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I1 2
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I2 3
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I3 4
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I4 5
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I5 6
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I6 7
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I7 8
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I8 9
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I9 10
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I10 11
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I11 12
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I12 13
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I13 14
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I14 15
#define EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I15 16
struct egress_InsertMetadata_tb_int_inst_0003_value {
    unsigned int action;
    union {
        struct {
        } _NoAction;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i0;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i1;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i2;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i3;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i4;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i5;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i6;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i7;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i8;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i9;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i10;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i11;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i12;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i13;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i14;
        struct {
        } egress_InsertMetadata_int_set_header_0003_i15;
    } u;
};
struct egress_InsertMetadata_tb_int_inst_0407_key {
    u8 field0; /* hdr.int_md.instruction_bitmap_0407 */
} __attribute__((aligned(4)));
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I0 1
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I1 2
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I2 3
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I3 4
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I4 5
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I5 6
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I6 7
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I7 8
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I8 9
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I9 10
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I10 11
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I11 12
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I12 13
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I13 14
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I14 15
#define EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I15 16
struct egress_InsertMetadata_tb_int_inst_0407_value {
    unsigned int action;
    union {
        struct {
        } _NoAction;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i0;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i1;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i2;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i3;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i4;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i5;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i6;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i7;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i8;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i9;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i10;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i11;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i12;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i13;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i14;
        struct {
        } egress_InsertMetadata_int_set_header_0407_i15;
    } u;
};

struct lookup_tbl_val {
    u32 table[2048];
};

struct hdr_md {
    struct headers cpumap_hdr;
    struct metadata cpumap_usermeta;
    __u8 __hook;
};

REGISTER_START()
REGISTER_TABLE_INNER(clone_session_tbl_inner, BPF_MAP_TYPE_HASH, elem_t, struct element, 64, 1, 1)
BPF_ANNOTATE_KV_PAIR(clone_session_tbl_inner, elem_t, struct element)
REGISTER_TABLE_OUTER(clone_session_tbl, BPF_MAP_TYPE_ARRAY_OF_MAPS, __u32, __u32, 1024, 1, clone_session_tbl_inner)
BPF_ANNOTATE_KV_PAIR(clone_session_tbl, __u32, __u32)
REGISTER_TABLE_INNER(multicast_grp_tbl_inner, BPF_MAP_TYPE_HASH, elem_t, struct element, 64, 2, 2)
BPF_ANNOTATE_KV_PAIR(multicast_grp_tbl_inner, elem_t, struct element)
REGISTER_TABLE_OUTER(multicast_grp_tbl, BPF_MAP_TYPE_ARRAY_OF_MAPS, __u32, __u32, 1024, 2, multicast_grp_tbl_inner)
BPF_ANNOTATE_KV_PAIR(multicast_grp_tbl, __u32, __u32)
REGISTER_TABLE(ingress_tbl_fwd, BPF_MAP_TYPE_HASH, struct ingress_tbl_fwd_key, struct ingress_tbl_fwd_value, 100)
BPF_ANNOTATE_KV_PAIR(ingress_tbl_fwd, struct ingress_tbl_fwd_key, struct ingress_tbl_fwd_value)
REGISTER_TABLE(ingress_tbl_fwd_defaultAction, BPF_MAP_TYPE_ARRAY, u32, struct ingress_tbl_fwd_value, 1)
BPF_ANNOTATE_KV_PAIR(ingress_tbl_fwd_defaultAction, u32, struct ingress_tbl_fwd_value)
REGISTER_TABLE(ingress_tbl_role_sink, BPF_MAP_TYPE_HASH, struct ingress_tbl_role_sink_key, struct ingress_tbl_role_sink_value, 100)
BPF_ANNOTATE_KV_PAIR(ingress_tbl_role_sink, struct ingress_tbl_role_sink_key, struct ingress_tbl_role_sink_value)
REGISTER_TABLE(ingress_tbl_role_sink_defaultAction, BPF_MAP_TYPE_ARRAY, u32, struct ingress_tbl_role_sink_value, 1)
BPF_ANNOTATE_KV_PAIR(ingress_tbl_role_sink_defaultAction, u32, struct ingress_tbl_role_sink_value)
REGISTER_TABLE(ingress_tbl_role_source, BPF_MAP_TYPE_HASH, struct ingress_tbl_role_source_key, struct ingress_tbl_role_source_value, 100)
BPF_ANNOTATE_KV_PAIR(ingress_tbl_role_source, struct ingress_tbl_role_source_key, struct ingress_tbl_role_source_value)
REGISTER_TABLE(ingress_tbl_role_source_defaultAction, BPF_MAP_TYPE_ARRAY, u32, struct ingress_tbl_role_source_value, 1)
BPF_ANNOTATE_KV_PAIR(ingress_tbl_role_source_defaultAction, u32, struct ingress_tbl_role_source_value)
REGISTER_TABLE(egress_InsertMetadata_tb_int_insert, BPF_MAP_TYPE_HASH, struct egress_InsertMetadata_tb_int_insert_key, struct egress_InsertMetadata_tb_int_insert_value, 100)
BPF_ANNOTATE_KV_PAIR(egress_InsertMetadata_tb_int_insert, struct egress_InsertMetadata_tb_int_insert_key, struct egress_InsertMetadata_tb_int_insert_value)
REGISTER_TABLE(egress_InsertMetadata_tb_int_insert_defaultAction, BPF_MAP_TYPE_ARRAY, u32, struct egress_InsertMetadata_tb_int_insert_value, 1)
BPF_ANNOTATE_KV_PAIR(egress_InsertMetadata_tb_int_insert_defaultAction, u32, struct egress_InsertMetadata_tb_int_insert_value)
REGISTER_TABLE(egress_InsertMetadata_tb_int_inst_0003, BPF_MAP_TYPE_HASH, struct egress_InsertMetadata_tb_int_inst_0003_key, struct egress_InsertMetadata_tb_int_inst_0003_value, 1024)
BPF_ANNOTATE_KV_PAIR(egress_InsertMetadata_tb_int_inst_0003, struct egress_InsertMetadata_tb_int_inst_0003_key, struct egress_InsertMetadata_tb_int_inst_0003_value)
REGISTER_TABLE(egress_InsertMetadata_tb_int_inst_0003_defaultAction, BPF_MAP_TYPE_ARRAY, u32, struct egress_InsertMetadata_tb_int_inst_0003_value, 1)
BPF_ANNOTATE_KV_PAIR(egress_InsertMetadata_tb_int_inst_0003_defaultAction, u32, struct egress_InsertMetadata_tb_int_inst_0003_value)
REGISTER_TABLE(egress_InsertMetadata_tb_int_inst_0407, BPF_MAP_TYPE_HASH, struct egress_InsertMetadata_tb_int_inst_0407_key, struct egress_InsertMetadata_tb_int_inst_0407_value, 1024)
BPF_ANNOTATE_KV_PAIR(egress_InsertMetadata_tb_int_inst_0407, struct egress_InsertMetadata_tb_int_inst_0407_key, struct egress_InsertMetadata_tb_int_inst_0407_value)
REGISTER_TABLE(egress_InsertMetadata_tb_int_inst_0407_defaultAction, BPF_MAP_TYPE_ARRAY, u32, struct egress_InsertMetadata_tb_int_inst_0407_value, 1)
BPF_ANNOTATE_KV_PAIR(egress_InsertMetadata_tb_int_inst_0407_defaultAction, u32, struct egress_InsertMetadata_tb_int_inst_0407_value)
REGISTER_TABLE(hdr_md_cpumap, BPF_MAP_TYPE_PERCPU_ARRAY, u32, struct hdr_md, 2)
BPF_ANNOTATE_KV_PAIR(hdr_md_cpumap, u32, struct hdr_md)
REGISTER_TABLE(crc_lookup_tbl, BPF_MAP_TYPE_ARRAY, u32, struct lookup_tbl_val, 1)
BPF_ANNOTATE_KV_PAIR(crc_lookup_tbl, u32, struct lookup_tbl_val)
REGISTER_END()

static __always_inline
void crc16_update(u16 * reg, const u8 * data, u16 data_size, const u16 poly) {
    if (data_size <= 8)
        data += data_size - 1;
    #pragma clang loop unroll(full)
    for (u16 i = 0; i < data_size; i++) {
        bpf_trace_message("CRC16: data byte: %x\n", *data);
        *reg ^= *data;
        for (u8 bit = 0; bit < 8; bit++) {
            *reg = (*reg) & 1 ? ((*reg) >> 1) ^ poly : (*reg) >> 1;
        }
        if (data_size <= 8)
            data--;
        else
            data++;
    }
}
static __always_inline u16 crc16_finalize(u16 reg) {
    return reg;
}
static __always_inline
void crc32_update(u32 * reg, const u8 * data, u16 data_size, const u32 poly) {
    u32* current = (u32*) data;
    struct lookup_tbl_val* lookup_table;
    u32 index = 0;
    lookup_table = BPF_MAP_LOOKUP_ELEM(crc_lookup_tbl, &index);
    u32 lookup_key = 0;
    u32 lookup_value = 0;
    u32 lookup_value1 = 0;
    u32 lookup_value2 = 0;
    u32 lookup_value3 = 0;
    u32 lookup_value4 = 0;
    u32 lookup_value5 = 0;
    u32 lookup_value6 = 0;
    u32 lookup_value7 = 0;
    u32 lookup_value8 = 0;
    u16 tmp = 0;
    if (lookup_table != NULL) {
        for (u16 i = data_size; i >= 8; i -= 8) {
            /* Vars one and two will have swapped byte order if data_size == 8 */
            if (data_size == 8) current = data + 4;
            bpf_trace_message("CRC32: data dword: %x\n", *current);
            u32 one = (data_size == 8 ? __builtin_bswap32(*current--) : *current++) ^ *reg;
            bpf_trace_message("CRC32: data dword: %x\n", *current);
            u32 two = (data_size == 8 ? __builtin_bswap32(*current--) : *current++);
            lookup_key = (one & 0x000000FF);
            lookup_value8 = lookup_table->table[(u16)(1792 + (u8)lookup_key)];
            lookup_key = (one >> 8) & 0x000000FF;
            lookup_value7 = lookup_table->table[(u16)(1536 + (u8)lookup_key)];
            lookup_key = (one >> 16) & 0x000000FF;
            lookup_value6 = lookup_table->table[(u16)(1280 + (u8)lookup_key)];
            lookup_key = one >> 24;
            lookup_value5 = lookup_table->table[(u16)(1024 + (u8)(lookup_key))];
            lookup_key = (two & 0x000000FF);
            lookup_value4 = lookup_table->table[(u16)(768 + (u8)lookup_key)];
            lookup_key = (two >> 8) & 0x000000FF;
            lookup_value3 = lookup_table->table[(u16)(512 + (u8)lookup_key)];
            lookup_key = (two >> 16) & 0x000000FF;
            lookup_value2 = lookup_table->table[(u16)(256 + (u8)lookup_key)];
            lookup_key = two >> 24;
            lookup_value1 = lookup_table->table[(u8)(lookup_key)];
            *reg = lookup_value8 ^ lookup_value7 ^ lookup_value6 ^ lookup_value5 ^
                   lookup_value4 ^ lookup_value3 ^ lookup_value2 ^ lookup_value1;
            tmp += 8;
        }
        volatile int std_algo_lookup_key = 0;
        if (data_size < 8) {
            unsigned char *currentChar = (unsigned char *) current;
            currentChar += data_size - 1;
            for (u16 i = tmp; i < data_size; i++) {
                bpf_trace_message("CRC32: data byte: %x\n", *currentChar);
                std_algo_lookup_key = (u32)(((*reg) & 0xFF) ^ *currentChar--);
                if (std_algo_lookup_key >= 0) {
                    lookup_value = lookup_table->table[(u8)(std_algo_lookup_key & 255)];
                }
                *reg = ((*reg) >> 8) ^ lookup_value;
            }
        } else {
            /* Consume data not processed by slice-by-8 algorithm above, these data are in network byte order */
            unsigned char *currentChar = (unsigned char *) current;
            for (u16 i = tmp; i < data_size; i++) {
                bpf_trace_message("CRC32: data byte: %x\n", *currentChar);
                std_algo_lookup_key = (u32)(((*reg) & 0xFF) ^ *currentChar++);
                if (std_algo_lookup_key >= 0) {
                    lookup_value = lookup_table->table[(u8)(std_algo_lookup_key & 255)];
                }
                *reg = ((*reg) >> 8) ^ lookup_value;
            }
        }
    }
}
static __always_inline u32 crc32_finalize(u32 reg) {
    return reg ^ 0xFFFFFFFF;
}
inline u16 csum16_add(u16 csum, u16 addend) {
    u16 res = csum;
    res += addend;
    return (res + (res < addend));
}
inline u16 csum16_sub(u16 csum, u16 addend) {
    return csum16_add(csum, ~addend);
}
static __always_inline
int do_for_each(SK_BUFF *skb, void *map, unsigned int max_iter, void (*a)(SK_BUFF *, void *))
{
    elem_t head_idx = {0, 0};
    struct element *elem = bpf_map_lookup_elem(map, &head_idx);
    if (!elem) {
        return -1;
    }
    if (elem->next_id.port == 0 && elem->next_id.instance == 0) {
               return 0;
    }
    elem_t next_id = elem->next_id;
    for (unsigned int i = 0; i < max_iter; i++) {
        struct element *elem = bpf_map_lookup_elem(map, &next_id);
        if (!elem) {
            break;
        }
        a(skb, &elem->entry);
        if (elem->next_id.port == 0 && elem->next_id.instance == 0) {
            break;
        }
        next_id = elem->next_id;
    }
    return 0;
}

static __always_inline
void do_clone(SK_BUFF *skb, void *data)
{
    struct clone_session_entry *entry = (struct clone_session_entry *) data;
    bpf_clone_redirect(skb, entry->egress_port, 0);
}

static __always_inline
int do_packet_clones(SK_BUFF * skb, void * map, __u32 session_id, PSA_PacketPath_t new_pkt_path, __u8 caller_id)
{
    struct psa_global_metadata * meta = (struct psa_global_metadata *) skb->cb;
    void * inner_map;
    inner_map = bpf_map_lookup_elem(map, &session_id);
    if (inner_map != NULL) {
        PSA_PacketPath_t original_pkt_path = meta->packet_path;
        meta->packet_path = new_pkt_path;
        if (do_for_each(skb, inner_map, CLONE_MAX_CLONES, &do_clone) < 0) {
            return -1;
        }
        meta->packet_path = original_pkt_path;
    } else {
    }
    return 0;
 }

static __always_inline
void add_prefix_and_entries(__u32 nr_entries,
            __u32 tuple_id,
            void *tuples_map,
            void *prefixes_map,
            void *key_mask,
            void *value_mask,
            void *keysPtrs[],
            void *valuesPtrs[]) {
    int ret = bpf_map_update_elem(prefixes_map, key_mask, value_mask, BPF_ANY);
    if (ret) {
        return;
    }
    if (nr_entries == 0) {
        return;
    }
    struct bpf_elf_map *tuple = bpf_map_lookup_elem(tuples_map, &tuple_id);
    if (tuple) {
        for (__u32 i = 0; i < nr_entries; i++) {
            int ret = bpf_map_update_elem(tuple, keysPtrs[i], valuesPtrs[i], BPF_ANY);
            if (ret) {
                return;
            } else {
            }
        }
    } else {
        return;
    }
}

SEC("classifier/map-initializer")
int map_initializer() {
    u32 ebpf_zero = 0;
    struct egress_InsertMetadata_tb_int_inst_0003_key key_0 = {
        .field0 = 0x0,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_0 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I0,
        .u = {.egress_InsertMetadata_int_set_header_0003_i0 = {}}
    };
    int ret = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_0, &value_0, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_1 = {
        .field0 = 0x1,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_1 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I1,
        .u = {.egress_InsertMetadata_int_set_header_0003_i1 = {}}
    };
    int ret_0 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_1, &value_1, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_2 = {
        .field0 = 0x2,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_2 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I2,
        .u = {.egress_InsertMetadata_int_set_header_0003_i2 = {}}
    };
    int ret_1 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_2, &value_2, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_3 = {
        .field0 = 0x3,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_3 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I3,
        .u = {.egress_InsertMetadata_int_set_header_0003_i3 = {}}
    };
    int ret_2 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_3, &value_3, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_4 = {
        .field0 = 0x4,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_4 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I4,
        .u = {.egress_InsertMetadata_int_set_header_0003_i4 = {}}
    };
    int ret_3 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_4, &value_4, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_5 = {
        .field0 = 0x5,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_5 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I5,
        .u = {.egress_InsertMetadata_int_set_header_0003_i5 = {}}
    };
    int ret_4 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_5, &value_5, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_6 = {
        .field0 = 0x6,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_6 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I6,
        .u = {.egress_InsertMetadata_int_set_header_0003_i6 = {}}
    };
    int ret_5 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_6, &value_6, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_7 = {
        .field0 = 0x7,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_7 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I7,
        .u = {.egress_InsertMetadata_int_set_header_0003_i7 = {}}
    };
    int ret_6 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_7, &value_7, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_8 = {
        .field0 = 0x8,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_8 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I8,
        .u = {.egress_InsertMetadata_int_set_header_0003_i8 = {}}
    };
    int ret_7 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_8, &value_8, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_9 = {
        .field0 = 0x9,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_9 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I9,
        .u = {.egress_InsertMetadata_int_set_header_0003_i9 = {}}
    };
    int ret_8 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_9, &value_9, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_10 = {
        .field0 = 0xa,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_10 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I10,
        .u = {.egress_InsertMetadata_int_set_header_0003_i10 = {}}
    };
    int ret_9 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_10, &value_10, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_11 = {
        .field0 = 0xb,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_11 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I11,
        .u = {.egress_InsertMetadata_int_set_header_0003_i11 = {}}
    };
    int ret_10 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_11, &value_11, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_12 = {
        .field0 = 0xc,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_12 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I12,
        .u = {.egress_InsertMetadata_int_set_header_0003_i12 = {}}
    };
    int ret_11 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_12, &value_12, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_13 = {
        .field0 = 0xd,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_13 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I13,
        .u = {.egress_InsertMetadata_int_set_header_0003_i13 = {}}
    };
    int ret_12 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_13, &value_13, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_14 = {
        .field0 = 0xe,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_14 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I14,
        .u = {.egress_InsertMetadata_int_set_header_0003_i14 = {}}
    };
    int ret_13 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_14, &value_14, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0003_key key_15 = {
        .field0 = 0xf,
    };
    struct egress_InsertMetadata_tb_int_inst_0003_value value_15 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I15,
        .u = {.egress_InsertMetadata_int_set_header_0003_i15 = {}}
    };
    int ret_14 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key_15, &value_15, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_16 = {
        .field0 = 0x0,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_16 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I0,
        .u = {.egress_InsertMetadata_int_set_header_0407_i0 = {}}
    };
    int ret_15 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_16, &value_16, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_17 = {
        .field0 = 0x1,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_17 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I1,
        .u = {.egress_InsertMetadata_int_set_header_0407_i1 = {}}
    };
    int ret_16 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_17, &value_17, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_18 = {
        .field0 = 0x2,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_18 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I2,
        .u = {.egress_InsertMetadata_int_set_header_0407_i2 = {}}
    };
    int ret_17 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_18, &value_18, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_19 = {
        .field0 = 0x3,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_19 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I3,
        .u = {.egress_InsertMetadata_int_set_header_0407_i3 = {}}
    };
    int ret_18 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_19, &value_19, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_20 = {
        .field0 = 0x4,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_20 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I4,
        .u = {.egress_InsertMetadata_int_set_header_0407_i4 = {}}
    };
    int ret_19 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_20, &value_20, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_21 = {
        .field0 = 0x5,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_21 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I5,
        .u = {.egress_InsertMetadata_int_set_header_0407_i5 = {}}
    };
    int ret_20 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_21, &value_21, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_22 = {
        .field0 = 0x6,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_22 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I6,
        .u = {.egress_InsertMetadata_int_set_header_0407_i6 = {}}
    };
    int ret_21 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_22, &value_22, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_23 = {
        .field0 = 0x7,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_23 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I7,
        .u = {.egress_InsertMetadata_int_set_header_0407_i7 = {}}
    };
    int ret_22 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_23, &value_23, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_24 = {
        .field0 = 0x8,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_24 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I8,
        .u = {.egress_InsertMetadata_int_set_header_0407_i8 = {}}
    };
    int ret_23 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_24, &value_24, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_25 = {
        .field0 = 0x9,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_25 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I9,
        .u = {.egress_InsertMetadata_int_set_header_0407_i9 = {}}
    };
    int ret_24 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_25, &value_25, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_26 = {
        .field0 = 0xa,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_26 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I10,
        .u = {.egress_InsertMetadata_int_set_header_0407_i10 = {}}
    };
    int ret_25 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_26, &value_26, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_27 = {
        .field0 = 0xb,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_27 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I11,
        .u = {.egress_InsertMetadata_int_set_header_0407_i11 = {}}
    };
    int ret_26 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_27, &value_27, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_28 = {
        .field0 = 0xc,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_28 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I12,
        .u = {.egress_InsertMetadata_int_set_header_0407_i12 = {}}
    };
    int ret_27 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_28, &value_28, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_29 = {
        .field0 = 0xd,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_29 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I13,
        .u = {.egress_InsertMetadata_int_set_header_0407_i13 = {}}
    };
    int ret_28 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_29, &value_29, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_30 = {
        .field0 = 0xe,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_30 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I14,
        .u = {.egress_InsertMetadata_int_set_header_0407_i14 = {}}
    };
    int ret_29 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_30, &value_30, BPF_ANY);
    struct egress_InsertMetadata_tb_int_inst_0407_key key_31 = {
        .field0 = 0xf,
    };
    struct egress_InsertMetadata_tb_int_inst_0407_value value_31 = {
        .action = EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I15,
        .u = {.egress_InsertMetadata_int_set_header_0407_i15 = {}}
    };
    int ret_30 = BPF_MAP_UPDATE_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key_31, &value_31, BPF_ANY);

    u32 lookup_tbl_key = 0;
    struct lookup_tbl_val* lookup_tbl_value = BPF_MAP_LOOKUP_ELEM(crc_lookup_tbl, &lookup_tbl_key);
    if (lookup_tbl_value != NULL){
        for (u16 i = 0; i <= 255; i++){
            u32 crc = i;
            for (u16 j = 0; j < 8; j++){
                crc = (crc >> 1) ^ ((crc & 1) * 3988292384);
            }
            lookup_tbl_value->table[i] = crc;
        }
        for (u16 i = 0; i <= 255; i++){
            lookup_tbl_value->table[256+i] = (lookup_tbl_value->table[0+i] >> 8) ^ lookup_tbl_value->table[(lookup_tbl_value->table[0+i] & 0xFF)];
            lookup_tbl_value->table[512+i] = (lookup_tbl_value->table[256+i] >> 8) ^ lookup_tbl_value->table[(lookup_tbl_value->table[256+i] & 0xFF)];
            lookup_tbl_value->table[768+i] = (lookup_tbl_value->table[512+i] >> 8) ^ lookup_tbl_value->table[(lookup_tbl_value->table[512+i] & 0xFF)];
            lookup_tbl_value->table[1024+i] = (lookup_tbl_value->table[768+i] >> 8) ^ lookup_tbl_value->table[(lookup_tbl_value->table[768+i] & 0xFF)];
            lookup_tbl_value->table[1280+i] = (lookup_tbl_value->table[1024+i] >> 8) ^ lookup_tbl_value->table[(lookup_tbl_value->table[1024+i] & 0xFF)];
            lookup_tbl_value->table[1536+i] = (lookup_tbl_value->table[1280+i] >> 8) ^ lookup_tbl_value->table[(lookup_tbl_value->table[1280+i] & 0xFF)];
            lookup_tbl_value->table[1792+i] = (lookup_tbl_value->table[1536+i] >> 8) ^ lookup_tbl_value->table[(lookup_tbl_value->table[1536+i] & 0xFF)];
        }
    }
    return 0;
}

SEC("xdp/xdp-ingress")
int xdp_func(struct xdp_md *skb) {
        void *data_end = (void *)(long)skb->data_end;
    struct ethhdr *eth = (struct ethhdr *)(long)skb->data;
    if ((void *)((struct ethhdr *) eth + 1) > data_end) {
        return XDP_ABORTED;
    }
    if (eth->h_proto == bpf_htons(0x0800) || eth->h_proto == bpf_htons(0x86DD)) {
        return XDP_PASS;
    }

    struct internal_metadata *meta;
    int ret = bpf_xdp_adjust_meta(skb, -(int)sizeof(*meta));
    if (ret < 0) {
        return XDP_ABORTED;
    }
    meta = (struct internal_metadata *)(unsigned long)skb->data_meta;
    eth = (void *)(long)skb->data;
    data_end = (void *)(long)skb->data_end;
    if ((void *) ((struct internal_metadata *) meta + 1) > (void *)(long)skb->data)
        return XDP_ABORTED;
    if ((void *)((struct ethhdr *) eth + 1) > data_end) {
        return XDP_ABORTED;
    }
    meta->pkt_ether_type = eth->h_proto;
    eth->h_proto = bpf_htons(0x0800);

    return XDP_PASS;
}
static __always_inline int process(struct __sk_buff *skb, struct headers *parsed_hdr, struct psa_ingress_output_metadata_t *ostd, struct psa_global_metadata *compiler_meta__, struct empty_t *resubmit_meta)
{
    unsigned ebpf_packetOffsetInBits = 0;
    unsigned ebpf_packetOffsetInBits_save = 0;
    ParserError_t ebpf_errorCode = NoError;
    void* pkt = ((void*)(long)skb->data);
    void* ebpf_packetEnd = ((void*)(long)skb->data_end);
    u32 ebpf_zero = 0;
    u32 ebpf_one = 1;
    unsigned char ebpf_byte;
    u32 pkt_len = skb->len;
    u64 tstamp = bpf_ktime_get_ns();
    u32 ebpf_input_port = skb->ifindex;
    if (ebpf_input_port == PSA_PORT_RECIRCULATE) {
        ebpf_input_port = P4C_PSA_PORT_RECIRCULATE;
    }

    struct metadata *meta;
    struct hdr_md *hdrMd;

    hdrMd = BPF_MAP_LOOKUP_ELEM(hdr_md_cpumap, &ebpf_zero);
    if (!hdrMd)
        return TC_ACT_SHOT;
    __builtin_memset(hdrMd, 0, sizeof(struct hdr_md));

    parsed_hdr = &(hdrMd->cpumap_hdr);
    meta = &(hdrMd->cpumap_usermeta);
    {
        struct psa_ingress_parser_input_metadata_t istd = {
            .ingress_port = ebpf_input_port,
            .packet_path = compiler_meta__->packet_path,
        };
        goto start;
        parse_int: {
/* extract(parsed_hdr->int_shim) */
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 32 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            parsed_hdr->int_shim.int_type = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->int_shim.next_protocol = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 2) & EBPF_MASK(u8, 2));
            ebpf_packetOffsetInBits += 2;

            parsed_hdr->int_shim.reserved = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 2));
            ebpf_packetOffsetInBits += 2;

            parsed_hdr->int_shim.int_total_length = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr->int_shim.udp_ip_dscp = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->int_shim.ebpf_valid = 1;

;
/* extract(parsed_hdr->int_md) */
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 96 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            parsed_hdr->int_md.ver = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->int_md.d = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 3) & EBPF_MASK(u8, 1));
            ebpf_packetOffsetInBits += 1;

            parsed_hdr->int_md.e = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 2) & EBPF_MASK(u8, 1));
            ebpf_packetOffsetInBits += 1;

            parsed_hdr->int_md.m = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 1) & EBPF_MASK(u8, 1));
            ebpf_packetOffsetInBits += 1;

            parsed_hdr->int_md.reserved = (u16)((load_word(pkt, BYTES(ebpf_packetOffsetInBits)) >> 13) & EBPF_MASK(u16, 12));
            ebpf_packetOffsetInBits += 12;

            parsed_hdr->int_md.hop_metadata_length = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 5));
            ebpf_packetOffsetInBits += 5;

            parsed_hdr->int_md.remaining_hop_count = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr->int_md.instruction_bitmap_0003 = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->int_md.instruction_bitmap_0407 = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->int_md.instruction_bitmap_0811 = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->int_md.instruction_bitmap_1215 = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->int_md.domain_specific_id = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->int_md.domain_specific_instruction = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->int_md.domains_specific_flags = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->int_md.ebpf_valid = 1;

;
             goto accept;
        }
        parse_ipv4: {
/* extract(parsed_hdr->ipv4) */
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 160 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            parsed_hdr->ipv4.version = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->ipv4.ihl = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->ipv4.dscp = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 2) & EBPF_MASK(u8, 6));
            ebpf_packetOffsetInBits += 6;

            parsed_hdr->ipv4.ecn = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 2));
            ebpf_packetOffsetInBits += 2;

            parsed_hdr->ipv4.totallen = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->ipv4.identification = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->ipv4.flags = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 5) & EBPF_MASK(u8, 3));
            ebpf_packetOffsetInBits += 3;

            parsed_hdr->ipv4.fragOffset = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u16, 13));
            ebpf_packetOffsetInBits += 13;

            parsed_hdr->ipv4.ttl = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr->ipv4.protocol = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr->ipv4.hdrChecksum = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->ipv4.srcAddr = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 32;

            parsed_hdr->ipv4.dstAddr = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 32;

            parsed_hdr->ipv4.ebpf_valid = 1;

;
            u8 select_0;
            select_0 = parsed_hdr->ipv4.protocol;
            if (select_0 == 17)goto parse_udp;
            if ((select_0 & 0x0) == (0x0 & 0x0))goto accept;
            else goto reject;
        }
        parse_udp: {
/* extract(parsed_hdr->udp) */
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 64 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            parsed_hdr->udp.srcPort = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->udp.dstPort = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->udp.length_ = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->udp.checksum = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->udp.ebpf_valid = 1;

;
            u8 select_1;
            select_1 = parsed_hdr->ipv4.dscp;
            if (select_1 == 23)goto parse_int;
            if ((select_1 & 0x0) == (0x0 & 0x0))goto accept;
            else goto reject;
        }
        start: {
/* extract(parsed_hdr->ethernet) */
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 112 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            parsed_hdr->ethernet.dstAddr = (u64)((load_dword(pkt, BYTES(ebpf_packetOffsetInBits)) >> 16) & EBPF_MASK(u64, 48));
            ebpf_packetOffsetInBits += 48;

            parsed_hdr->ethernet.srcAddr = (u64)((load_dword(pkt, BYTES(ebpf_packetOffsetInBits)) >> 16) & EBPF_MASK(u64, 48));
            ebpf_packetOffsetInBits += 48;

            parsed_hdr->ethernet.etherType = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->ethernet.ebpf_valid = 1;

;
            u16 select_2;
            select_2 = parsed_hdr->ethernet.etherType;
            if (select_2 == 2048)goto parse_ipv4;
            if ((select_2 & 0x0) == (0x0 & 0x0))goto accept;
            else goto reject;
        }

        reject: {
            if (ebpf_errorCode == 0) {
                return TC_ACT_SHOT;
            }
            goto accept;
        }

    }

    accept: {
        struct psa_ingress_input_metadata_t istd = {
            .ingress_port = ebpf_input_port,
            .packet_path = compiler_meta__->packet_path,
            .parser_error = ebpf_errorCode,
    };
        istd.ingress_timestamp = tstamp;
        u8 hit;
        struct psa_ingress_output_metadata_t *meta_1;
        u32 egress_port_1;
        struct psa_ingress_output_metadata_t *meta_2;
        u32 egress_port_3;
        {
/* parsed_hdr->umeta.setValid() */
            parsed_hdr->umeta.ebpf_valid = true;
            /* tbl_fwd_0.apply() */
            {
                /* construct key */
                struct ingress_tbl_fwd_key key = {};
                key.field0 = parsed_hdr->ipv4.dstAddr;
                /* value */
                struct ingress_tbl_fwd_value *value = NULL;
                /* perform lookup */
                value = BPF_MAP_LOOKUP_ELEM(ingress_tbl_fwd, &key);
                if (value == NULL) {
                    /* miss; find default action */
                    hit = 0;
                    value = BPF_MAP_LOOKUP_ELEM(ingress_tbl_fwd_defaultAction, &ebpf_zero);
                } else {
                    hit = 1;
                }
                if (value != NULL) {
                    /* run action */
                    switch (value->action) {
                        case INGRESS_TBL_FWD_ACT_INGRESS_DO_FORWARD: 
                            {
/* forward_counter_0.count() */
                                __sync_fetch_and_add(&(value->ingress_forward_counter.packets), 1);
;
                                                                parsed_hdr->umeta.ingress_timestamp = (u64)istd.ingress_timestamp;
                                                                parsed_hdr->umeta.ingress_port = (u32)istd.ingress_port;
                                                                parsed_hdr->ethernet.srcAddr = value->u.ingress_do_forward.srcAddr;
                                                                parsed_hdr->ethernet.dstAddr = value->u.ingress_do_forward.dstAddr;
                                                                meta_1 = ostd;
                                                                egress_port_1 = value->u.ingress_do_forward.egress_port;
                                                                meta_1->drop = false;
                                                                meta_1->multicast_group = 0;
                                                                meta_1->egress_port = egress_port_1;
                                                                ostd = meta_1;
                            }
                            break;
                        case 0: 
                            {
                            }
                            break;
                        default:
                            return TC_ACT_SHOT;
                    }
                } else {
                    return TC_ACT_SHOT;
;
                }
            }
            if (hit) {
/* tbl_role_source_0.apply() */
                {
                    /* construct key */
                    struct ingress_tbl_role_source_key key = {};
                    key.field0 = parsed_hdr->ipv4.srcAddr;
                    key.field1 = parsed_hdr->udp.srcPort;
                    key.field2 = istd.ingress_port;
                    /* value */
                    struct ingress_tbl_role_source_value *value = NULL;
                    /* perform lookup */
                    value = BPF_MAP_LOOKUP_ELEM(ingress_tbl_role_source, &key);
                    if (value == NULL) {
                        /* miss; find default action */
                        hit = 0;
                        value = BPF_MAP_LOOKUP_ELEM(ingress_tbl_role_source_defaultAction, &ebpf_zero);
                    } else {
                        hit = 1;
                    }
                    if (value != NULL) {
                        /* run action */
                        switch (value->action) {
                            case INGRESS_TBL_ROLE_SOURCE_ACT_INGRESS_SET_SOURCE: 
                                {
/* int_src_counter_0.count() */
                                    __sync_fetch_and_add(&(value->ingress_int_src_counter.packets), 1);
;
                                    /* parsed_hdr->int_shim.setValid() */
                                    parsed_hdr->int_shim.ebpf_valid = true;
                                                                        parsed_hdr->int_shim.int_type = 1;
                                                                        parsed_hdr->int_shim.next_protocol = 0;
                                                                        parsed_hdr->int_shim.reserved = 0;
                                                                        parsed_hdr->int_shim.int_total_length = 3;
                                                                        parsed_hdr->int_shim.udp_ip_dscp = ((u16)parsed_hdr->ipv4.dscp << 2);
                                                                        parsed_hdr->ipv4.dscp = 23;
                                    /* parsed_hdr->int_md.setValid() */
                                    parsed_hdr->int_md.ebpf_valid = true;
                                                                        parsed_hdr->int_md.ver = 2;
                                                                        parsed_hdr->int_md.d = 0;
                                                                        parsed_hdr->int_md.e = 0;
                                                                        parsed_hdr->int_md.m = 0;
                                                                        parsed_hdr->int_md.reserved = 0;
                                                                        parsed_hdr->int_md.hop_metadata_length = value->u.ingress_set_source.mdLen;
                                                                        parsed_hdr->int_md.remaining_hop_count = value->u.ingress_set_source.remHops;
                                                                        parsed_hdr->int_md.instruction_bitmap_0003 = value->u.ingress_set_source.iBit0;
                                                                        parsed_hdr->int_md.instruction_bitmap_0407 = value->u.ingress_set_source.iBit1;
                                                                        parsed_hdr->int_md.instruction_bitmap_0811 = value->u.ingress_set_source.iBit2;
                                                                        parsed_hdr->int_md.instruction_bitmap_1215 = value->u.ingress_set_source.iBit3;
                                                                        parsed_hdr->int_md.domain_specific_id = 0;
                                                                        parsed_hdr->int_md.domain_specific_instruction = 0;
                                                                        parsed_hdr->int_md.domains_specific_flags = 0;
                                                                        parsed_hdr->udp.length_ = (parsed_hdr->udp.length_ + 16);
                                                                        parsed_hdr->ipv4.totallen = (parsed_hdr->ipv4.totallen + 16);
                                }
                                break;
                            case 0: 
                                {
                                }
                                break;
                            default:
                                return TC_ACT_SHOT;
                        }
                    } else {
                        return TC_ACT_SHOT;
;
                    }
                }
;
                /* tbl_role_sink_0.apply() */
                {
                    /* construct key */
                    struct ingress_tbl_role_sink_key key = {};
                    key.field0 = parsed_hdr->ipv4.dstAddr;
                    key.field1 = parsed_hdr->udp.srcPort;
                    key.field2 = ostd->egress_port;
                    /* value */
                    struct ingress_tbl_role_sink_value *value = NULL;
                    /* perform lookup */
                    value = BPF_MAP_LOOKUP_ELEM(ingress_tbl_role_sink, &key);
                    if (value == NULL) {
                        /* miss; find default action */
                        hit = 0;
                        value = BPF_MAP_LOOKUP_ELEM(ingress_tbl_role_sink_defaultAction, &ebpf_zero);
                    } else {
                        hit = 1;
                    }
                    if (value != NULL) {
                        /* run action */
                        switch (value->action) {
                            case INGRESS_TBL_ROLE_SINK_ACT_INGRESS_SET_SINK: 
                                {
/* int_sink_counter_0.count() */
                                    __sync_fetch_and_add(&(value->ingress_int_sink_counter.packets), 1);
;
                                                                        parsed_hdr->umeta.isINTSink = 1;
                                                                        ostd->clone = true;
                                                                        ostd->clone_session_id = value->u.ingress_set_sink.csi;
                                                                        meta_2 = ostd;
                                                                        egress_port_3 = value->u.ingress_set_sink.port;
                                                                        meta_2->drop = false;
                                                                        meta_2->multicast_group = 0;
                                                                        meta_2->egress_port = egress_port_3;
                                                                        ostd = meta_2;
                                }
                                break;
                            case 0: 
                                {
                                }
                                break;
                            default:
                                return TC_ACT_SHOT;
                        }
                    } else {
                        return TC_ACT_SHOT;
;
                    }
                }
;
            }
        }
    }
    {
{
;
            ;
            ;
            ;
            ;
            ;
        }

        
        if (ostd->clone) {
            do_packet_clones(skb, &clone_session_tbl, ostd->clone_session_id, CLONE_I2E, 1);
        }
        if (ostd->drop) {
            return TC_ACT_SHOT;
        }
        if (ostd->resubmit) {
            compiler_meta__->packet_path = RESUBMIT;
            return TC_ACT_UNSPEC;
        }
        int outHeaderLength = 0;
        if (parsed_hdr->umeta.ebpf_valid) {
            outHeaderLength += 104;
        }
;        if (parsed_hdr->ethernet.ebpf_valid) {
            outHeaderLength += 112;
        }
;        if (parsed_hdr->ipv4.ebpf_valid) {
            outHeaderLength += 160;
        }
;        if (parsed_hdr->udp.ebpf_valid) {
            outHeaderLength += 64;
        }
;        if (parsed_hdr->int_shim.ebpf_valid) {
            outHeaderLength += 32;
        }
;        if (parsed_hdr->int_md.ebpf_valid) {
            outHeaderLength += 96;
        }
;
        int outHeaderOffset = BYTES(outHeaderLength) - BYTES(ebpf_packetOffsetInBits);
        if (outHeaderOffset != 0) {
            int returnCode = 0;
            returnCode = bpf_skb_adjust_room(skb, outHeaderOffset, 1, 0);
            if (returnCode) {
                return TC_ACT_SHOT;
            }
        }
        pkt = ((void*)(long)skb->data);
        ebpf_packetEnd = ((void*)(long)skb->data_end);
        ebpf_packetOffsetInBits = 0;
        if (parsed_hdr->umeta.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 104)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&parsed_hdr->umeta.isINTSink))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 1, 7, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 1;

            parsed_hdr->umeta.ingress_port = htonl(parsed_hdr->umeta.ingress_port);
            ebpf_byte = ((char*)(&parsed_hdr->umeta.ingress_port))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 7, 0, (ebpf_byte >> 1));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0 + 1, 1, 7, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->umeta.ingress_port))[1];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 1, 7, 0, (ebpf_byte >> 1));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 1 + 1, 1, 7, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->umeta.ingress_port))[2];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 2, 7, 0, (ebpf_byte >> 1));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 2 + 1, 1, 7, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->umeta.ingress_port))[3];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 3, 7, 0, (ebpf_byte >> 1));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 3 + 1, 1, 7, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

            parsed_hdr->umeta.ingress_timestamp = htonll(parsed_hdr->umeta.ingress_timestamp);
            ebpf_byte = ((char*)(&parsed_hdr->umeta.ingress_timestamp))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 7, 0, (ebpf_byte >> 1));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0 + 1, 1, 7, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->umeta.ingress_timestamp))[1];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 1, 7, 0, (ebpf_byte >> 1));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 1 + 1, 1, 7, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->umeta.ingress_timestamp))[2];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 2, 7, 0, (ebpf_byte >> 1));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 2 + 1, 1, 7, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->umeta.ingress_timestamp))[3];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 3, 7, 0, (ebpf_byte >> 1));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 3 + 1, 1, 7, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->umeta.ingress_timestamp))[4];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 4, 7, 0, (ebpf_byte >> 1));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 4 + 1, 1, 7, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->umeta.ingress_timestamp))[5];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 5, 7, 0, (ebpf_byte >> 1));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 5 + 1, 1, 7, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->umeta.ingress_timestamp))[6];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 6, 7, 0, (ebpf_byte >> 1));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 6 + 1, 1, 7, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->umeta.ingress_timestamp))[7];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 7, 7, 0, (ebpf_byte >> 1));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 7 + 1, 1, 7, (ebpf_byte));
            ebpf_packetOffsetInBits += 64;

            ebpf_byte = ((char*)(&parsed_hdr->umeta.padding))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 7, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 7;

        }
;        if (parsed_hdr->ethernet.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 112)) {
                return TC_ACT_SHOT;
            }
            
            parsed_hdr->ethernet.dstAddr = htonll(parsed_hdr->ethernet.dstAddr << 16);
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.dstAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.dstAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.dstAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.dstAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.dstAddr))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.dstAddr))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            parsed_hdr->ethernet.srcAddr = htonll(parsed_hdr->ethernet.srcAddr << 16);
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.srcAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.srcAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.srcAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.srcAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.srcAddr))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.srcAddr))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            parsed_hdr->ethernet.etherType = bpf_htons(parsed_hdr->ethernet.etherType);
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.etherType))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.etherType))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
;        if (parsed_hdr->ipv4.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 160)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.version))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr->ipv4.ihl))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr->ipv4.dscp))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 6, 2, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 6;

            ebpf_byte = ((char*)(&parsed_hdr->ipv4.ecn))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 2, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 2;

            parsed_hdr->ipv4.totallen = bpf_htons(parsed_hdr->ipv4.totallen);
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.totallen))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.totallen))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->ipv4.identification = bpf_htons(parsed_hdr->ipv4.identification);
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.identification))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.identification))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            ebpf_byte = ((char*)(&parsed_hdr->ipv4.flags))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 3, 5, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 3;

            parsed_hdr->ipv4.fragOffset = bpf_htons(parsed_hdr->ipv4.fragOffset << 3);
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.fragOffset))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 5, 0, (ebpf_byte >> 3));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0 + 1, 3, 5, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.fragOffset))[1];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 1, 5, 0, (ebpf_byte >> 3));
            ebpf_packetOffsetInBits += 13;

            ebpf_byte = ((char*)(&parsed_hdr->ipv4.ttl))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            ebpf_byte = ((char*)(&parsed_hdr->ipv4.protocol))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr->ipv4.hdrChecksum = bpf_htons(parsed_hdr->ipv4.hdrChecksum);
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.hdrChecksum))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.hdrChecksum))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->ipv4.srcAddr = htonl(parsed_hdr->ipv4.srcAddr);
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.srcAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.srcAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.srcAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.srcAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

            parsed_hdr->ipv4.dstAddr = htonl(parsed_hdr->ipv4.dstAddr);
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.dstAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.dstAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.dstAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.dstAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

        }
;        if (parsed_hdr->udp.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 64)) {
                return TC_ACT_SHOT;
            }
            
            parsed_hdr->udp.srcPort = bpf_htons(parsed_hdr->udp.srcPort);
            ebpf_byte = ((char*)(&parsed_hdr->udp.srcPort))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->udp.srcPort))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->udp.dstPort = bpf_htons(parsed_hdr->udp.dstPort);
            ebpf_byte = ((char*)(&parsed_hdr->udp.dstPort))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->udp.dstPort))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->udp.length_ = bpf_htons(parsed_hdr->udp.length_);
            ebpf_byte = ((char*)(&parsed_hdr->udp.length_))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->udp.length_))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->udp.checksum = bpf_htons(parsed_hdr->udp.checksum);
            ebpf_byte = ((char*)(&parsed_hdr->udp.checksum))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->udp.checksum))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
;        if (parsed_hdr->int_shim.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 32)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&parsed_hdr->int_shim.int_type))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr->int_shim.next_protocol))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 2, 2, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 2;

            ebpf_byte = ((char*)(&parsed_hdr->int_shim.reserved))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 2, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 2;

            ebpf_byte = ((char*)(&parsed_hdr->int_shim.int_total_length))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr->int_shim.udp_ip_dscp = bpf_htons(parsed_hdr->int_shim.udp_ip_dscp);
            ebpf_byte = ((char*)(&parsed_hdr->int_shim.udp_ip_dscp))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_shim.udp_ip_dscp))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
;        if (parsed_hdr->int_md.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 96)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&parsed_hdr->int_md.ver))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.d))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 1, 3, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 1;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.e))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 1, 2, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 1;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.m))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 1, 1, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 1;

            parsed_hdr->int_md.reserved = bpf_htons(parsed_hdr->int_md.reserved << 4);
            ebpf_byte = ((char*)(&parsed_hdr->int_md.reserved))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 1, 0, (ebpf_byte >> 7));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0 + 1, 7, 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_md.reserved))[1];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 1, 1, 0, (ebpf_byte >> 7));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 1 + 1, 7, 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 12;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.hop_metadata_length))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 5, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 5;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.remaining_hop_count))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.instruction_bitmap_0003))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.instruction_bitmap_0407))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.instruction_bitmap_0811))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.instruction_bitmap_1215))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->int_md.domain_specific_id = bpf_htons(parsed_hdr->int_md.domain_specific_id);
            ebpf_byte = ((char*)(&parsed_hdr->int_md.domain_specific_id))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_md.domain_specific_id))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->int_md.domain_specific_instruction = bpf_htons(parsed_hdr->int_md.domain_specific_instruction);
            ebpf_byte = ((char*)(&parsed_hdr->int_md.domain_specific_instruction))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_md.domain_specific_instruction))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->int_md.domains_specific_flags = bpf_htons(parsed_hdr->int_md.domains_specific_flags);
            ebpf_byte = ((char*)(&parsed_hdr->int_md.domains_specific_flags))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_md.domains_specific_flags))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
;
    }
    return -1;
}
SEC("classifier/tc-ingress")
int tc_ingress_func(struct __sk_buff *skb) {
    struct psa_global_metadata *compiler_meta__ = (struct psa_global_metadata *) skb->cb;
    if (compiler_meta__->pass_to_kernel == true) return TC_ACT_OK;
    if (compiler_meta__->packet_path == NORMAL) {
        compiler_meta__->mark = 153;
        struct internal_metadata *md = (struct internal_metadata *)(unsigned long)skb->data_meta;
        if ((void *) ((struct internal_metadata *) md + 1) <= (void *)(long)skb->data) {
            __u16 *ether_type = (__u16 *) ((void *) (long)skb->data + 12);
            if ((void *) ((__u16 *) ether_type + 1) > (void *) (long) skb->data_end) {
                return TC_ACT_SHOT;
            }
            *ether_type = md->pkt_ether_type;
        }
    }
    struct psa_ingress_output_metadata_t ostd = {
            .drop = true,
    };

    struct empty_t resubmit_meta;
    struct hdr_md *hdrMd;
    struct headers *parsed_hdr;
    int ret = -1;
    #pragma clang loop unroll(disable)
    for (int i = 0; i < 4; i++) {
        ostd.resubmit = 0;
        ret = process(skb, (struct headers *) parsed_hdr, &ostd, compiler_meta__, &resubmit_meta);
        if (ostd.drop == 1 || ostd.resubmit == 0) {
            break;
        }
    }
    if (ret != -1) {
        return ret;
    }
    if (ostd.multicast_group != 0) {
        do_packet_clones(skb, &multicast_grp_tbl, ostd.multicast_group, NORMAL_MULTICAST, 2);
        return TC_ACT_SHOT;
    }
    skb->priority = ostd.class_of_service;
    if (!ostd.drop && ostd.egress_port == 0) {
        compiler_meta__->pass_to_kernel = true;
        return bpf_redirect(skb->ifindex, BPF_F_INGRESS);
    }
    return bpf_redirect(ostd.egress_port, 0);
}

SEC("classifier/tc-egress")
int tc_egress_func(SK_BUFF *skb) {
    struct psa_global_metadata *compiler_meta__ = (struct psa_global_metadata *) skb->cb;
    if (compiler_meta__->mark != 153) {
        return TC_ACT_OK;
    }
    unsigned ebpf_packetOffsetInBits = 0;
    unsigned ebpf_packetOffsetInBits_save = 0;
    ParserError_t ebpf_errorCode = NoError;
    void* pkt = ((void*)(long)skb->data);
    void* ebpf_packetEnd = ((void*)(long)skb->data_end);
    u32 ebpf_zero = 0;
    u32 ebpf_one = 1;
    unsigned char ebpf_byte;
    u32 pkt_len = skb->len;
    u64 tstamp = bpf_ktime_get_ns();
    u32 ebpf_input_port = skb->ifindex;
    if (ebpf_input_port == PSA_PORT_RECIRCULATE) {
        ebpf_input_port = P4C_PSA_PORT_RECIRCULATE;
    }
    struct metadata *meta;

    struct hdr_md *hdrMd;
    struct headers *parsed_hdr;
    hdrMd = BPF_MAP_LOOKUP_ELEM(hdr_md_cpumap, &ebpf_one);
    if (!hdrMd)
        return TC_ACT_SHOT;
    __builtin_memset(hdrMd, 0, sizeof(struct hdr_md));

    parsed_hdr = &(hdrMd->cpumap_hdr);
    meta = &(hdrMd->cpumap_usermeta);
    struct psa_egress_output_metadata_t ostd = {
       .clone = false,
            .drop = false,
        };

    struct psa_egress_input_metadata_t istd = {
            .class_of_service = skb->priority,
            .egress_port = ebpf_input_port,
            .packet_path = compiler_meta__->packet_path,
            .instance = compiler_meta__->instance,
            .parser_error = ebpf_errorCode,
        };
    istd.egress_timestamp = tstamp;
    {
        struct psa_egress_parser_input_metadata_t istd = {
            .egress_port = ebpf_input_port,
            .packet_path = compiler_meta__->packet_path,
        };
        goto start;
        parse_ethernet: {
/* extract(parsed_hdr->ethernet) */
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 112 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            parsed_hdr->ethernet.dstAddr = (u64)((load_dword(pkt, BYTES(ebpf_packetOffsetInBits)) >> 16) & EBPF_MASK(u64, 48));
            ebpf_packetOffsetInBits += 48;

            parsed_hdr->ethernet.srcAddr = (u64)((load_dword(pkt, BYTES(ebpf_packetOffsetInBits)) >> 16) & EBPF_MASK(u64, 48));
            ebpf_packetOffsetInBits += 48;

            parsed_hdr->ethernet.etherType = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->ethernet.ebpf_valid = 1;

;
            u16 select_3;
            select_3 = parsed_hdr->ethernet.etherType;
            if (select_3 == 2048)goto parse_ipv4;
            if ((select_3 & 0x0) == (0x0 & 0x0))goto accept;
            else goto reject;
        }
        parse_int: {
/* extract(parsed_hdr->int_shim) */
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 32 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            parsed_hdr->int_shim.int_type = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->int_shim.next_protocol = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 2) & EBPF_MASK(u8, 2));
            ebpf_packetOffsetInBits += 2;

            parsed_hdr->int_shim.reserved = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 2));
            ebpf_packetOffsetInBits += 2;

            parsed_hdr->int_shim.int_total_length = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr->int_shim.udp_ip_dscp = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->int_shim.ebpf_valid = 1;

;
/* extract(parsed_hdr->int_md) */
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 96 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            parsed_hdr->int_md.ver = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->int_md.d = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 3) & EBPF_MASK(u8, 1));
            ebpf_packetOffsetInBits += 1;

            parsed_hdr->int_md.e = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 2) & EBPF_MASK(u8, 1));
            ebpf_packetOffsetInBits += 1;

            parsed_hdr->int_md.m = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 1) & EBPF_MASK(u8, 1));
            ebpf_packetOffsetInBits += 1;

            parsed_hdr->int_md.reserved = (u16)((load_word(pkt, BYTES(ebpf_packetOffsetInBits)) >> 13) & EBPF_MASK(u16, 12));
            ebpf_packetOffsetInBits += 12;

            parsed_hdr->int_md.hop_metadata_length = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 5));
            ebpf_packetOffsetInBits += 5;

            parsed_hdr->int_md.remaining_hop_count = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr->int_md.instruction_bitmap_0003 = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->int_md.instruction_bitmap_0407 = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->int_md.instruction_bitmap_0811 = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->int_md.instruction_bitmap_1215 = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->int_md.domain_specific_id = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->int_md.domain_specific_instruction = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->int_md.domains_specific_flags = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->int_md.ebpf_valid = 1;

;
            u8 select_4;
            select_4 = parsed_hdr->int_md.remaining_hop_count;
            if (select_4 == 1)goto parse_int_sink;
            if ((select_4 & 0x0) == (0x0 & 0x0))goto accept;
            else goto reject;
        }
        parse_int_sink: {
/* extract(parsed_hdr->int_data) */
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 128 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            parsed_hdr->int_data.metadata_stack[0] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0) >> 0));
            parsed_hdr->int_data.metadata_stack[1] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1) >> 0));
            parsed_hdr->int_data.metadata_stack[2] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2) >> 0));
            parsed_hdr->int_data.metadata_stack[3] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3) >> 0));
            parsed_hdr->int_data.metadata_stack[4] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4) >> 0));
            parsed_hdr->int_data.metadata_stack[5] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5) >> 0));
            parsed_hdr->int_data.metadata_stack[6] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 6) >> 0));
            parsed_hdr->int_data.metadata_stack[7] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 7) >> 0));
            parsed_hdr->int_data.metadata_stack[8] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 8) >> 0));
            parsed_hdr->int_data.metadata_stack[9] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 9) >> 0));
            parsed_hdr->int_data.metadata_stack[10] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 10) >> 0));
            parsed_hdr->int_data.metadata_stack[11] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 11) >> 0));
            parsed_hdr->int_data.metadata_stack[12] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 12) >> 0));
            parsed_hdr->int_data.metadata_stack[13] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 13) >> 0));
            parsed_hdr->int_data.metadata_stack[14] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 14) >> 0));
            parsed_hdr->int_data.metadata_stack[15] = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 15) >> 0));
            ebpf_packetOffsetInBits += 128;

            parsed_hdr->int_data.ebpf_valid = 1;

;
             goto accept;
        }
        parse_ipv4: {
/* extract(parsed_hdr->ipv4) */
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 160 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            parsed_hdr->ipv4.version = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->ipv4.ihl = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->ipv4.dscp = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 2) & EBPF_MASK(u8, 6));
            ebpf_packetOffsetInBits += 6;

            parsed_hdr->ipv4.ecn = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 2));
            ebpf_packetOffsetInBits += 2;

            parsed_hdr->ipv4.totallen = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->ipv4.identification = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->ipv4.flags = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 5) & EBPF_MASK(u8, 3));
            ebpf_packetOffsetInBits += 3;

            parsed_hdr->ipv4.fragOffset = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u16, 13));
            ebpf_packetOffsetInBits += 13;

            parsed_hdr->ipv4.ttl = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr->ipv4.protocol = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr->ipv4.hdrChecksum = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->ipv4.srcAddr = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 32;

            parsed_hdr->ipv4.dstAddr = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 32;

            parsed_hdr->ipv4.ebpf_valid = 1;

;
            u8 select_5;
            select_5 = parsed_hdr->ipv4.protocol;
            if (select_5 == 17)goto parse_udp;
            if ((select_5 & 0x0) == (0x0 & 0x0))goto accept;
            else goto reject;
        }
        parse_udp: {
/* extract(parsed_hdr->udp) */
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 64 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            parsed_hdr->udp.srcPort = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->udp.dstPort = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->udp.length_ = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->udp.checksum = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->udp.ebpf_valid = 1;

;
            u8 select_6;
            select_6 = parsed_hdr->ipv4.dscp;
            if (select_6 == 23)goto parse_int;
            if ((select_6 & 0x0) == (0x0 & 0x0))goto accept;
            else goto reject;
        }
        parse_umeta: {
/* extract(parsed_hdr->umeta) */
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 104 + 1)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            parsed_hdr->umeta.isINTSink = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 7) & EBPF_MASK(u8, 1));
            ebpf_packetOffsetInBits += 1;

            parsed_hdr->umeta.ingress_port = (u32)((load_dword(pkt, BYTES(ebpf_packetOffsetInBits)) >> 31) & EBPF_MASK(u32, 32));
            ebpf_packetOffsetInBits += 32;

            parsed_hdr->umeta.ingress_timestamp = (u64)((load_dword(pkt, BYTES(ebpf_packetOffsetInBits)) >> -1));
            ebpf_packetOffsetInBits += 64;

            parsed_hdr->umeta.padding = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 7));
            ebpf_packetOffsetInBits += 7;

            parsed_hdr->umeta.ebpf_valid = 1;

;
             goto parse_ethernet;
        }
        start: {
            u32 select_7;
            select_7 = istd.packet_path;
            if (select_7 == 3)goto parse_ethernet;
            if (select_7 == 0)goto parse_umeta;
            if ((select_7 & 0x0) == (0x0 & 0x0))goto accept;
            else goto reject;
        }

        reject: {
            if (ebpf_errorCode == 0) {
                return TC_ACT_SHOT;
            }
            goto accept;
        }

    }
    accept:
    istd.parser_error = ebpf_errorCode;

    {

        u8 hit_0;
        {
/* InsertMetadata_tb_int_insert.apply() */
            {
                /* construct key */
                struct egress_InsertMetadata_tb_int_insert_key key = {};
                key.field0 = /* parsed_hdr->int_shim.isValid() */
                parsed_hdr->int_shim.ebpf_valid;
                /* value */
                struct egress_InsertMetadata_tb_int_insert_value *value = NULL;
                /* perform lookup */
                value = BPF_MAP_LOOKUP_ELEM(egress_InsertMetadata_tb_int_insert, &key);
                if (value == NULL) {
                    /* miss; find default action */
                    hit_0 = 0;
                    value = BPF_MAP_LOOKUP_ELEM(egress_InsertMetadata_tb_int_insert_defaultAction, &ebpf_zero);
                } else {
                    hit_0 = 1;
                }
                if (value != NULL) {
                    /* run action */
                    switch (value->action) {
                        case EGRESS_INSERTMETADATA_TB_INT_INSERT_ACT_EGRESS_INSERTMETADATA_INIT_METADATA: 
                            {
/* InsertMetadata_insert_counter.count() */
                                __sync_fetch_and_add(&(value->egress_InsertMetadata_insert_counter.packets), 1);
;
                                                                meta->isTransit = true;
                                                                meta->node_id = value->u.egress_InsertMetadata_init_metadata.node_id;
                            }
                            break;
                        case 0: 
                            {
                            }
                            break;
                        default:
                            return TC_ACT_SHOT;
                    }
                } else {
                    return TC_ACT_SHOT;
;
                }
            }
            if (hit_0) {
/* InsertMetadata_tb_int_inst.apply() */
                {
                    /* construct key */
                    struct egress_InsertMetadata_tb_int_inst_0003_key key = {};
                    key.field0 = parsed_hdr->int_md.instruction_bitmap_0003;
                    /* value */
                    struct egress_InsertMetadata_tb_int_inst_0003_value *value = NULL;
                    /* perform lookup */
                    value = BPF_MAP_LOOKUP_ELEM(egress_InsertMetadata_tb_int_inst_0003, &key);
                    if (value == NULL) {
                        /* miss; find default action */
                        hit_0 = 0;
                        value = BPF_MAP_LOOKUP_ELEM(egress_InsertMetadata_tb_int_inst_0003_defaultAction, &ebpf_zero);
                    } else {
                        hit_0 = 1;
                    }
                    if (value != NULL) {
                        /* run action */
                        switch (value->action) {
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I0: 
                                {
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I1: 
                                {
{
/* parsed_hdr->int_queue_info.setValid() */
                                        parsed_hdr->int_queue_info.ebpf_valid = true;
                                                                                parsed_hdr->int_queue_info.queue_id = 0;
                                                                                parsed_hdr->int_queue_info.queue_occupancy = 0;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 1);
                                                                                meta->new_bytes = (meta->new_bytes + 4);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I2: 
                                {
{
/* parsed_hdr->int_hop_latency.setValid() */
                                        parsed_hdr->int_hop_latency.ebpf_valid = true;
                                                                                parsed_hdr->int_hop_latency.hop_latency = (u32)((u64)istd.egress_timestamp - parsed_hdr->umeta.ingress_timestamp);
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 1);
                                                                                meta->new_bytes = (meta->new_bytes + 4);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I3: 
                                {
{
/* parsed_hdr->int_queue_info.setValid() */
                                        parsed_hdr->int_queue_info.ebpf_valid = true;
                                                                                parsed_hdr->int_queue_info.queue_id = 0;
                                                                                parsed_hdr->int_queue_info.queue_occupancy = 0;
                                    }
                                    {
/* parsed_hdr->int_hop_latency.setValid() */
                                        parsed_hdr->int_hop_latency.ebpf_valid = true;
                                                                                parsed_hdr->int_hop_latency.hop_latency = (u32)((u64)istd.egress_timestamp - parsed_hdr->umeta.ingress_timestamp);
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 2);
                                                                                meta->new_bytes = (meta->new_bytes + 8);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I4: 
                                {
{
/* parsed_hdr->int_l1_interfaces.setValid() */
                                        parsed_hdr->int_l1_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l1_interfaces.ingress_id = (u16)parsed_hdr->umeta.ingress_port;
                                                                                parsed_hdr->int_l1_interfaces.egress_id = (u16)(u32)istd.egress_port;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 1);
                                                                                meta->new_bytes = (meta->new_bytes + 4);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I5: 
                                {
{
/* parsed_hdr->int_queue_info.setValid() */
                                        parsed_hdr->int_queue_info.ebpf_valid = true;
                                                                                parsed_hdr->int_queue_info.queue_id = 0;
                                                                                parsed_hdr->int_queue_info.queue_occupancy = 0;
                                    }
                                    {
/* parsed_hdr->int_l1_interfaces.setValid() */
                                        parsed_hdr->int_l1_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l1_interfaces.ingress_id = (u16)parsed_hdr->umeta.ingress_port;
                                                                                parsed_hdr->int_l1_interfaces.egress_id = (u16)(u32)istd.egress_port;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 2);
                                                                                meta->new_bytes = (meta->new_bytes + 8);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I6: 
                                {
{
/* parsed_hdr->int_hop_latency.setValid() */
                                        parsed_hdr->int_hop_latency.ebpf_valid = true;
                                                                                parsed_hdr->int_hop_latency.hop_latency = (u32)((u64)istd.egress_timestamp - parsed_hdr->umeta.ingress_timestamp);
                                    }
                                    {
/* parsed_hdr->int_l1_interfaces.setValid() */
                                        parsed_hdr->int_l1_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l1_interfaces.ingress_id = (u16)parsed_hdr->umeta.ingress_port;
                                                                                parsed_hdr->int_l1_interfaces.egress_id = (u16)(u32)istd.egress_port;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 2);
                                                                                meta->new_bytes = (meta->new_bytes + 8);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I7: 
                                {
{
/* parsed_hdr->int_queue_info.setValid() */
                                        parsed_hdr->int_queue_info.ebpf_valid = true;
                                                                                parsed_hdr->int_queue_info.queue_id = 0;
                                                                                parsed_hdr->int_queue_info.queue_occupancy = 0;
                                    }
                                    {
/* parsed_hdr->int_hop_latency.setValid() */
                                        parsed_hdr->int_hop_latency.ebpf_valid = true;
                                                                                parsed_hdr->int_hop_latency.hop_latency = (u32)((u64)istd.egress_timestamp - parsed_hdr->umeta.ingress_timestamp);
                                    }
                                    {
/* parsed_hdr->int_l1_interfaces.setValid() */
                                        parsed_hdr->int_l1_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l1_interfaces.ingress_id = (u16)parsed_hdr->umeta.ingress_port;
                                                                                parsed_hdr->int_l1_interfaces.egress_id = (u16)(u32)istd.egress_port;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 3);
                                                                                meta->new_bytes = (meta->new_bytes + 12);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I8: 
                                {
{
/* parsed_hdr->int_node_id.setValid() */
                                        parsed_hdr->int_node_id.ebpf_valid = true;
                                                                                parsed_hdr->int_node_id.node_id = meta->node_id;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 1);
                                                                                meta->new_bytes = (meta->new_bytes + 4);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I9: 
                                {
{
/* parsed_hdr->int_queue_info.setValid() */
                                        parsed_hdr->int_queue_info.ebpf_valid = true;
                                                                                parsed_hdr->int_queue_info.queue_id = 0;
                                                                                parsed_hdr->int_queue_info.queue_occupancy = 0;
                                    }
                                    {
/* parsed_hdr->int_node_id.setValid() */
                                        parsed_hdr->int_node_id.ebpf_valid = true;
                                                                                parsed_hdr->int_node_id.node_id = meta->node_id;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 2);
                                                                                meta->new_bytes = (meta->new_bytes + 8);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I10: 
                                {
{
/* parsed_hdr->int_hop_latency.setValid() */
                                        parsed_hdr->int_hop_latency.ebpf_valid = true;
                                                                                parsed_hdr->int_hop_latency.hop_latency = (u32)((u64)istd.egress_timestamp - parsed_hdr->umeta.ingress_timestamp);
                                    }
                                    {
/* parsed_hdr->int_node_id.setValid() */
                                        parsed_hdr->int_node_id.ebpf_valid = true;
                                                                                parsed_hdr->int_node_id.node_id = meta->node_id;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 2);
                                                                                meta->new_bytes = (meta->new_bytes + 8);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I11: 
                                {
{
/* parsed_hdr->int_queue_info.setValid() */
                                        parsed_hdr->int_queue_info.ebpf_valid = true;
                                                                                parsed_hdr->int_queue_info.queue_id = 0;
                                                                                parsed_hdr->int_queue_info.queue_occupancy = 0;
                                    }
                                    {
/* parsed_hdr->int_hop_latency.setValid() */
                                        parsed_hdr->int_hop_latency.ebpf_valid = true;
                                                                                parsed_hdr->int_hop_latency.hop_latency = (u32)((u64)istd.egress_timestamp - parsed_hdr->umeta.ingress_timestamp);
                                    }
                                    {
/* parsed_hdr->int_node_id.setValid() */
                                        parsed_hdr->int_node_id.ebpf_valid = true;
                                                                                parsed_hdr->int_node_id.node_id = meta->node_id;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 3);
                                                                                meta->new_bytes = (meta->new_bytes + 12);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I12: 
                                {
{
/* parsed_hdr->int_l1_interfaces.setValid() */
                                        parsed_hdr->int_l1_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l1_interfaces.ingress_id = (u16)parsed_hdr->umeta.ingress_port;
                                                                                parsed_hdr->int_l1_interfaces.egress_id = (u16)(u32)istd.egress_port;
                                    }
                                    {
/* parsed_hdr->int_node_id.setValid() */
                                        parsed_hdr->int_node_id.ebpf_valid = true;
                                                                                parsed_hdr->int_node_id.node_id = meta->node_id;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 2);
                                                                                meta->new_bytes = (meta->new_bytes + 8);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I13: 
                                {
{
/* parsed_hdr->int_queue_info.setValid() */
                                        parsed_hdr->int_queue_info.ebpf_valid = true;
                                                                                parsed_hdr->int_queue_info.queue_id = 0;
                                                                                parsed_hdr->int_queue_info.queue_occupancy = 0;
                                    }
                                    {
/* parsed_hdr->int_l1_interfaces.setValid() */
                                        parsed_hdr->int_l1_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l1_interfaces.ingress_id = (u16)parsed_hdr->umeta.ingress_port;
                                                                                parsed_hdr->int_l1_interfaces.egress_id = (u16)(u32)istd.egress_port;
                                    }
                                    {
/* parsed_hdr->int_node_id.setValid() */
                                        parsed_hdr->int_node_id.ebpf_valid = true;
                                                                                parsed_hdr->int_node_id.node_id = meta->node_id;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 3);
                                                                                meta->new_bytes = (meta->new_bytes + 12);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I14: 
                                {
{
/* parsed_hdr->int_hop_latency.setValid() */
                                        parsed_hdr->int_hop_latency.ebpf_valid = true;
                                                                                parsed_hdr->int_hop_latency.hop_latency = (u32)((u64)istd.egress_timestamp - parsed_hdr->umeta.ingress_timestamp);
                                    }
                                    {
/* parsed_hdr->int_l1_interfaces.setValid() */
                                        parsed_hdr->int_l1_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l1_interfaces.ingress_id = (u16)parsed_hdr->umeta.ingress_port;
                                                                                parsed_hdr->int_l1_interfaces.egress_id = (u16)(u32)istd.egress_port;
                                    }
                                    {
/* parsed_hdr->int_node_id.setValid() */
                                        parsed_hdr->int_node_id.ebpf_valid = true;
                                                                                parsed_hdr->int_node_id.node_id = meta->node_id;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 3);
                                                                                meta->new_bytes = (meta->new_bytes + 12);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0003_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0003_I15: 
                                {
{
/* parsed_hdr->int_queue_info.setValid() */
                                        parsed_hdr->int_queue_info.ebpf_valid = true;
                                                                                parsed_hdr->int_queue_info.queue_id = 0;
                                                                                parsed_hdr->int_queue_info.queue_occupancy = 0;
                                    }
                                    {
/* parsed_hdr->int_hop_latency.setValid() */
                                        parsed_hdr->int_hop_latency.ebpf_valid = true;
                                                                                parsed_hdr->int_hop_latency.hop_latency = (u32)((u64)istd.egress_timestamp - parsed_hdr->umeta.ingress_timestamp);
                                    }
                                    {
/* parsed_hdr->int_l1_interfaces.setValid() */
                                        parsed_hdr->int_l1_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l1_interfaces.ingress_id = (u16)parsed_hdr->umeta.ingress_port;
                                                                                parsed_hdr->int_l1_interfaces.egress_id = (u16)(u32)istd.egress_port;
                                    }
                                    {
/* parsed_hdr->int_node_id.setValid() */
                                        parsed_hdr->int_node_id.ebpf_valid = true;
                                                                                parsed_hdr->int_node_id.node_id = meta->node_id;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 4);
                                                                                meta->new_bytes = (meta->new_bytes + 16);
                                    }
                                }
                                break;
                            case 0: 
                                {
                                }
                                break;
                            default:
                                return TC_ACT_SHOT;
                        }
                    } else {
                        return TC_ACT_SHOT;
;
                    }
                }
;
                /* InsertMetadata_tb_int_inst_0.apply() */
                {
                    /* construct key */
                    struct egress_InsertMetadata_tb_int_inst_0407_key key = {};
                    key.field0 = parsed_hdr->int_md.instruction_bitmap_0407;
                    /* value */
                    struct egress_InsertMetadata_tb_int_inst_0407_value *value = NULL;
                    /* perform lookup */
                    value = BPF_MAP_LOOKUP_ELEM(egress_InsertMetadata_tb_int_inst_0407, &key);
                    if (value == NULL) {
                        /* miss; find default action */
                        hit_0 = 0;
                        value = BPF_MAP_LOOKUP_ELEM(egress_InsertMetadata_tb_int_inst_0407_defaultAction, &ebpf_zero);
                    } else {
                        hit_0 = 1;
                    }
                    if (value != NULL) {
                        /* run action */
                        switch (value->action) {
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I0: 
                                {
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I1: 
                                {
{
/* parsed_hdr->int_egress_tx.setValid() */
                                        parsed_hdr->int_egress_tx.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_tx.egress_tx_utilization = 0;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 1);
                                                                                meta->new_bytes = (meta->new_bytes + 4);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I2: 
                                {
{
/* parsed_hdr->int_l2_interfaces.setValid() */
                                        parsed_hdr->int_l2_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l2_interfaces.ingress_id = 0;
                                                                                parsed_hdr->int_l2_interfaces.egress_id = 0;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 2);
                                                                                meta->new_bytes = (meta->new_bytes + 8);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I3: 
                                {
{
/* parsed_hdr->int_egress_tx.setValid() */
                                        parsed_hdr->int_egress_tx.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_tx.egress_tx_utilization = 0;
                                    }
                                    {
/* parsed_hdr->int_l2_interfaces.setValid() */
                                        parsed_hdr->int_l2_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l2_interfaces.ingress_id = 0;
                                                                                parsed_hdr->int_l2_interfaces.egress_id = 0;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 3);
                                                                                meta->new_bytes = (meta->new_bytes + 12);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I4: 
                                {
{
/* parsed_hdr->int_egress_timestamp.setValid() */
                                        parsed_hdr->int_egress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_timestamp.egress_timestamp = (u64)istd.egress_timestamp;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 1);
                                                                                meta->new_bytes = (meta->new_bytes + 4);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I5: 
                                {
{
/* parsed_hdr->int_egress_tx.setValid() */
                                        parsed_hdr->int_egress_tx.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_tx.egress_tx_utilization = 0;
                                    }
                                    {
/* parsed_hdr->int_egress_timestamp.setValid() */
                                        parsed_hdr->int_egress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_timestamp.egress_timestamp = (u64)istd.egress_timestamp;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 2);
                                                                                meta->new_bytes = (meta->new_bytes + 8);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I6: 
                                {
{
/* parsed_hdr->int_l2_interfaces.setValid() */
                                        parsed_hdr->int_l2_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l2_interfaces.ingress_id = 0;
                                                                                parsed_hdr->int_l2_interfaces.egress_id = 0;
                                    }
                                    {
/* parsed_hdr->int_egress_timestamp.setValid() */
                                        parsed_hdr->int_egress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_timestamp.egress_timestamp = (u64)istd.egress_timestamp;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 3);
                                                                                meta->new_bytes = (meta->new_bytes + 12);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I7: 
                                {
{
/* parsed_hdr->int_egress_tx.setValid() */
                                        parsed_hdr->int_egress_tx.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_tx.egress_tx_utilization = 0;
                                    }
                                    {
/* parsed_hdr->int_l2_interfaces.setValid() */
                                        parsed_hdr->int_l2_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l2_interfaces.ingress_id = 0;
                                                                                parsed_hdr->int_l2_interfaces.egress_id = 0;
                                    }
                                    {
/* parsed_hdr->int_egress_timestamp.setValid() */
                                        parsed_hdr->int_egress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_timestamp.egress_timestamp = (u64)istd.egress_timestamp;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 4);
                                                                                meta->new_bytes = (meta->new_bytes + 16);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I8: 
                                {
{
/* parsed_hdr->int_ingress_timestamp.setValid() */
                                        parsed_hdr->int_ingress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_ingress_timestamp.ingress_timestamp = meta->ingress_timestamp;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 1);
                                                                                meta->new_bytes = (meta->new_bytes + 4);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I9: 
                                {
{
/* parsed_hdr->int_egress_tx.setValid() */
                                        parsed_hdr->int_egress_tx.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_tx.egress_tx_utilization = 0;
                                    }
                                    {
/* parsed_hdr->int_ingress_timestamp.setValid() */
                                        parsed_hdr->int_ingress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_ingress_timestamp.ingress_timestamp = meta->ingress_timestamp;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 2);
                                                                                meta->new_bytes = (meta->new_bytes + 8);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I10: 
                                {
{
/* parsed_hdr->int_l2_interfaces.setValid() */
                                        parsed_hdr->int_l2_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l2_interfaces.ingress_id = 0;
                                                                                parsed_hdr->int_l2_interfaces.egress_id = 0;
                                    }
                                    {
/* parsed_hdr->int_ingress_timestamp.setValid() */
                                        parsed_hdr->int_ingress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_ingress_timestamp.ingress_timestamp = meta->ingress_timestamp;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 3);
                                                                                meta->new_bytes = (meta->new_bytes + 12);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I11: 
                                {
{
/* parsed_hdr->int_egress_tx.setValid() */
                                        parsed_hdr->int_egress_tx.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_tx.egress_tx_utilization = 0;
                                    }
                                    {
/* parsed_hdr->int_l2_interfaces.setValid() */
                                        parsed_hdr->int_l2_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l2_interfaces.ingress_id = 0;
                                                                                parsed_hdr->int_l2_interfaces.egress_id = 0;
                                    }
                                    {
/* parsed_hdr->int_ingress_timestamp.setValid() */
                                        parsed_hdr->int_ingress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_ingress_timestamp.ingress_timestamp = meta->ingress_timestamp;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 4);
                                                                                meta->new_bytes = (meta->new_bytes + 16);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I12: 
                                {
{
/* parsed_hdr->int_egress_timestamp.setValid() */
                                        parsed_hdr->int_egress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_timestamp.egress_timestamp = (u64)istd.egress_timestamp;
                                    }
                                    {
/* parsed_hdr->int_ingress_timestamp.setValid() */
                                        parsed_hdr->int_ingress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_ingress_timestamp.ingress_timestamp = meta->ingress_timestamp;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 2);
                                                                                meta->new_bytes = (meta->new_bytes + 8);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I13: 
                                {
{
/* parsed_hdr->int_egress_tx.setValid() */
                                        parsed_hdr->int_egress_tx.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_tx.egress_tx_utilization = 0;
                                    }
                                    {
/* parsed_hdr->int_egress_timestamp.setValid() */
                                        parsed_hdr->int_egress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_timestamp.egress_timestamp = (u64)istd.egress_timestamp;
                                    }
                                    {
/* parsed_hdr->int_ingress_timestamp.setValid() */
                                        parsed_hdr->int_ingress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_ingress_timestamp.ingress_timestamp = meta->ingress_timestamp;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 3);
                                                                                meta->new_bytes = (meta->new_bytes + 12);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I14: 
                                {
{
/* parsed_hdr->int_l2_interfaces.setValid() */
                                        parsed_hdr->int_l2_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l2_interfaces.ingress_id = 0;
                                                                                parsed_hdr->int_l2_interfaces.egress_id = 0;
                                    }
                                    {
/* parsed_hdr->int_egress_timestamp.setValid() */
                                        parsed_hdr->int_egress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_timestamp.egress_timestamp = (u64)istd.egress_timestamp;
                                    }
                                    {
/* parsed_hdr->int_ingress_timestamp.setValid() */
                                        parsed_hdr->int_ingress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_ingress_timestamp.ingress_timestamp = meta->ingress_timestamp;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 4);
                                                                                meta->new_bytes = (meta->new_bytes + 16);
                                    }
                                }
                                break;
                            case EGRESS_INSERTMETADATA_TB_INT_INST_0407_ACT_EGRESS_INSERTMETADATA_INT_SET_HEADER_0407_I15: 
                                {
{
/* parsed_hdr->int_egress_tx.setValid() */
                                        parsed_hdr->int_egress_tx.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_tx.egress_tx_utilization = 0;
                                    }
                                    {
/* parsed_hdr->int_l2_interfaces.setValid() */
                                        parsed_hdr->int_l2_interfaces.ebpf_valid = true;
                                                                                parsed_hdr->int_l2_interfaces.ingress_id = 0;
                                                                                parsed_hdr->int_l2_interfaces.egress_id = 0;
                                    }
                                    {
/* parsed_hdr->int_egress_timestamp.setValid() */
                                        parsed_hdr->int_egress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_egress_timestamp.egress_timestamp = (u64)istd.egress_timestamp;
                                    }
                                    {
/* parsed_hdr->int_ingress_timestamp.setValid() */
                                        parsed_hdr->int_ingress_timestamp.ebpf_valid = true;
                                                                                parsed_hdr->int_ingress_timestamp.ingress_timestamp = meta->ingress_timestamp;
                                    }
                                    {
                                        meta->new_words = (meta->new_words + 5);
                                                                                meta->new_bytes = (meta->new_bytes + 20);
                                    }
                                }
                                break;
                            case 0: 
                                {
                                }
                                break;
                            default:
                                return TC_ACT_SHOT;
                        }
                    } else {
                        return TC_ACT_SHOT;
;
                    }
                }
;
                                parsed_hdr->int_md.remaining_hop_count = (parsed_hdr->int_md.remaining_hop_count + 255);
                                parsed_hdr->ipv4.totallen = (parsed_hdr->ipv4.totallen + meta->new_bytes);
                                parsed_hdr->udp.length_ = (parsed_hdr->udp.length_ + meta->new_bytes);
                                parsed_hdr->int_shim.int_total_length = (parsed_hdr->int_shim.int_total_length + meta->new_words);
            }
            if (istd.packet_path == 3) {
                parsed_hdr->ipv4.totallen = (parsed_hdr->ipv4.totallen - (u16)((parsed_hdr->int_shim.int_total_length + 1) << 2));
                                parsed_hdr->udp.length_ = (parsed_hdr->udp.length_ - (u16)((parsed_hdr->int_shim.int_total_length + 1) << 2));
                /* parsed_hdr->int_shim.setInvalid() */
                parsed_hdr->int_shim.ebpf_valid = false;
                /* parsed_hdr->int_md.setInvalid() */
                parsed_hdr->int_md.ebpf_valid = false;
                /* parsed_hdr->int_node_id.setInvalid() */
                parsed_hdr->int_node_id.ebpf_valid = false;
                /* parsed_hdr->int_l1_interfaces.setInvalid() */
                parsed_hdr->int_l1_interfaces.ebpf_valid = false;
                /* parsed_hdr->int_hop_latency.setInvalid() */
                parsed_hdr->int_hop_latency.ebpf_valid = false;
                /* parsed_hdr->int_queue_info.setInvalid() */
                parsed_hdr->int_queue_info.ebpf_valid = false;
                /* parsed_hdr->int_ingress_timestamp.setInvalid() */
                parsed_hdr->int_ingress_timestamp.ebpf_valid = false;
                /* parsed_hdr->int_egress_timestamp.setInvalid() */
                parsed_hdr->int_egress_timestamp.ebpf_valid = false;
                /* parsed_hdr->int_l2_interfaces.setInvalid() */
                parsed_hdr->int_l2_interfaces.ebpf_valid = false;
                /* parsed_hdr->int_egress_tx.setInvalid() */
                parsed_hdr->int_egress_tx.ebpf_valid = false;
                /* parsed_hdr->int_buffer_info.setInvalid() */
                parsed_hdr->int_buffer_info.ebpf_valid = false;
                /* parsed_hdr->int_checksum.setInvalid() */
                parsed_hdr->int_checksum.ebpf_valid = false;
                /* parsed_hdr->int_data.setInvalid() */
                parsed_hdr->int_data.ebpf_valid = false;
            }
            else {
if (/* parsed_hdr->umeta.isValid() */
                parsed_hdr->umeta.ebpf_valid && parsed_hdr->umeta.isINTSink == 1) {
                    parsed_hdr->ethernet.dstAddr = 94687117444112;
                                        parsed_hdr->ipv4.dstAddr = 0xa00040a;
                }            }

            /* parsed_hdr->umeta.setInvalid() */
            parsed_hdr->umeta.ebpf_valid = false;
        }
    }
    {
{
;
            ;
            ;
            ;
            ;
            ;
            ;
            ;
            ;
            ;
            ;
            ;
            ;
            ;
            ;
            ;
        }

        int outHeaderLength = 0;
        if (parsed_hdr->ethernet.ebpf_valid) {
            outHeaderLength += 112;
        }
;        if (parsed_hdr->ipv4.ebpf_valid) {
            outHeaderLength += 160;
        }
;        if (parsed_hdr->udp.ebpf_valid) {
            outHeaderLength += 64;
        }
;        if (parsed_hdr->int_shim.ebpf_valid) {
            outHeaderLength += 32;
        }
;        if (parsed_hdr->int_md.ebpf_valid) {
            outHeaderLength += 96;
        }
;        if (parsed_hdr->int_node_id.ebpf_valid) {
            outHeaderLength += 32;
        }
;        if (parsed_hdr->int_l1_interfaces.ebpf_valid) {
            outHeaderLength += 32;
        }
;        if (parsed_hdr->int_hop_latency.ebpf_valid) {
            outHeaderLength += 32;
        }
;        if (parsed_hdr->int_queue_info.ebpf_valid) {
            outHeaderLength += 32;
        }
;        if (parsed_hdr->int_ingress_timestamp.ebpf_valid) {
            outHeaderLength += 64;
        }
;        if (parsed_hdr->int_egress_timestamp.ebpf_valid) {
            outHeaderLength += 64;
        }
;        if (parsed_hdr->int_l2_interfaces.ebpf_valid) {
            outHeaderLength += 64;
        }
;        if (parsed_hdr->int_egress_tx.ebpf_valid) {
            outHeaderLength += 32;
        }
;        if (parsed_hdr->int_buffer_info.ebpf_valid) {
            outHeaderLength += 32;
        }
;        if (parsed_hdr->int_checksum.ebpf_valid) {
            outHeaderLength += 32;
        }
;        if (parsed_hdr->int_data.ebpf_valid) {
            outHeaderLength += 128;
        }
;
        int outHeaderOffset = BYTES(outHeaderLength) - BYTES(ebpf_packetOffsetInBits);
        if (outHeaderOffset != 0) {
            int returnCode = 0;
            returnCode = bpf_skb_adjust_room(skb, outHeaderOffset, 1, 0);
            if (returnCode) {
                return TC_ACT_SHOT;
            }
        }
        pkt = ((void*)(long)skb->data);
        ebpf_packetEnd = ((void*)(long)skb->data_end);
        ebpf_packetOffsetInBits = 0;
        if (parsed_hdr->ethernet.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 112)) {
                return TC_ACT_SHOT;
            }
            
            parsed_hdr->ethernet.dstAddr = htonll(parsed_hdr->ethernet.dstAddr << 16);
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.dstAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.dstAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.dstAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.dstAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.dstAddr))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.dstAddr))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            parsed_hdr->ethernet.srcAddr = htonll(parsed_hdr->ethernet.srcAddr << 16);
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.srcAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.srcAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.srcAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.srcAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.srcAddr))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.srcAddr))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            parsed_hdr->ethernet.etherType = bpf_htons(parsed_hdr->ethernet.etherType);
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.etherType))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ethernet.etherType))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
;        if (parsed_hdr->ipv4.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 160)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.version))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr->ipv4.ihl))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr->ipv4.dscp))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 6, 2, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 6;

            ebpf_byte = ((char*)(&parsed_hdr->ipv4.ecn))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 2, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 2;

            parsed_hdr->ipv4.totallen = bpf_htons(parsed_hdr->ipv4.totallen);
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.totallen))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.totallen))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->ipv4.identification = bpf_htons(parsed_hdr->ipv4.identification);
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.identification))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.identification))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            ebpf_byte = ((char*)(&parsed_hdr->ipv4.flags))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 3, 5, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 3;

            parsed_hdr->ipv4.fragOffset = bpf_htons(parsed_hdr->ipv4.fragOffset << 3);
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.fragOffset))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 5, 0, (ebpf_byte >> 3));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0 + 1, 3, 5, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.fragOffset))[1];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 1, 5, 0, (ebpf_byte >> 3));
            ebpf_packetOffsetInBits += 13;

            ebpf_byte = ((char*)(&parsed_hdr->ipv4.ttl))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            ebpf_byte = ((char*)(&parsed_hdr->ipv4.protocol))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr->ipv4.hdrChecksum = bpf_htons(parsed_hdr->ipv4.hdrChecksum);
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.hdrChecksum))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.hdrChecksum))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->ipv4.srcAddr = htonl(parsed_hdr->ipv4.srcAddr);
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.srcAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.srcAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.srcAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.srcAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

            parsed_hdr->ipv4.dstAddr = htonl(parsed_hdr->ipv4.dstAddr);
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.dstAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.dstAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.dstAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->ipv4.dstAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

        }
;        if (parsed_hdr->udp.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 64)) {
                return TC_ACT_SHOT;
            }
            
            parsed_hdr->udp.srcPort = bpf_htons(parsed_hdr->udp.srcPort);
            ebpf_byte = ((char*)(&parsed_hdr->udp.srcPort))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->udp.srcPort))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->udp.dstPort = bpf_htons(parsed_hdr->udp.dstPort);
            ebpf_byte = ((char*)(&parsed_hdr->udp.dstPort))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->udp.dstPort))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->udp.length_ = bpf_htons(parsed_hdr->udp.length_);
            ebpf_byte = ((char*)(&parsed_hdr->udp.length_))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->udp.length_))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->udp.checksum = bpf_htons(parsed_hdr->udp.checksum);
            ebpf_byte = ((char*)(&parsed_hdr->udp.checksum))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->udp.checksum))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
;        if (parsed_hdr->int_shim.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 32)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&parsed_hdr->int_shim.int_type))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr->int_shim.next_protocol))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 2, 2, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 2;

            ebpf_byte = ((char*)(&parsed_hdr->int_shim.reserved))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 2, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 2;

            ebpf_byte = ((char*)(&parsed_hdr->int_shim.int_total_length))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr->int_shim.udp_ip_dscp = bpf_htons(parsed_hdr->int_shim.udp_ip_dscp);
            ebpf_byte = ((char*)(&parsed_hdr->int_shim.udp_ip_dscp))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_shim.udp_ip_dscp))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
;        if (parsed_hdr->int_md.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 96)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&parsed_hdr->int_md.ver))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.d))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 1, 3, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 1;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.e))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 1, 2, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 1;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.m))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 1, 1, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 1;

            parsed_hdr->int_md.reserved = bpf_htons(parsed_hdr->int_md.reserved << 4);
            ebpf_byte = ((char*)(&parsed_hdr->int_md.reserved))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 1, 0, (ebpf_byte >> 7));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0 + 1, 7, 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_md.reserved))[1];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 1, 1, 0, (ebpf_byte >> 7));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 1 + 1, 7, 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 12;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.hop_metadata_length))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 5, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 5;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.remaining_hop_count))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.instruction_bitmap_0003))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.instruction_bitmap_0407))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.instruction_bitmap_0811))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr->int_md.instruction_bitmap_1215))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            parsed_hdr->int_md.domain_specific_id = bpf_htons(parsed_hdr->int_md.domain_specific_id);
            ebpf_byte = ((char*)(&parsed_hdr->int_md.domain_specific_id))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_md.domain_specific_id))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->int_md.domain_specific_instruction = bpf_htons(parsed_hdr->int_md.domain_specific_instruction);
            ebpf_byte = ((char*)(&parsed_hdr->int_md.domain_specific_instruction))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_md.domain_specific_instruction))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->int_md.domains_specific_flags = bpf_htons(parsed_hdr->int_md.domains_specific_flags);
            ebpf_byte = ((char*)(&parsed_hdr->int_md.domains_specific_flags))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_md.domains_specific_flags))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
;        if (parsed_hdr->int_node_id.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 32)) {
                return TC_ACT_SHOT;
            }
            
            parsed_hdr->int_node_id.node_id = htonl(parsed_hdr->int_node_id.node_id);
            ebpf_byte = ((char*)(&parsed_hdr->int_node_id.node_id))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_node_id.node_id))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_node_id.node_id))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_node_id.node_id))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

        }
;        if (parsed_hdr->int_l1_interfaces.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 32)) {
                return TC_ACT_SHOT;
            }
            
            parsed_hdr->int_l1_interfaces.ingress_id = bpf_htons(parsed_hdr->int_l1_interfaces.ingress_id);
            ebpf_byte = ((char*)(&parsed_hdr->int_l1_interfaces.ingress_id))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_l1_interfaces.ingress_id))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr->int_l1_interfaces.egress_id = bpf_htons(parsed_hdr->int_l1_interfaces.egress_id);
            ebpf_byte = ((char*)(&parsed_hdr->int_l1_interfaces.egress_id))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_l1_interfaces.egress_id))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
;        if (parsed_hdr->int_hop_latency.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 32)) {
                return TC_ACT_SHOT;
            }
            
            parsed_hdr->int_hop_latency.hop_latency = htonl(parsed_hdr->int_hop_latency.hop_latency);
            ebpf_byte = ((char*)(&parsed_hdr->int_hop_latency.hop_latency))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_hop_latency.hop_latency))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_hop_latency.hop_latency))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_hop_latency.hop_latency))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

        }
;        if (parsed_hdr->int_queue_info.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 32)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&parsed_hdr->int_queue_info.queue_id))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr->int_queue_info.queue_occupancy = htonl(parsed_hdr->int_queue_info.queue_occupancy << 8);
            ebpf_byte = ((char*)(&parsed_hdr->int_queue_info.queue_occupancy))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_queue_info.queue_occupancy))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_queue_info.queue_occupancy))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_packetOffsetInBits += 24;

        }
;        if (parsed_hdr->int_ingress_timestamp.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 64)) {
                return TC_ACT_SHOT;
            }
            
            parsed_hdr->int_ingress_timestamp.ingress_timestamp = htonll(parsed_hdr->int_ingress_timestamp.ingress_timestamp);
            ebpf_byte = ((char*)(&parsed_hdr->int_ingress_timestamp.ingress_timestamp))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_ingress_timestamp.ingress_timestamp))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_ingress_timestamp.ingress_timestamp))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_ingress_timestamp.ingress_timestamp))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_ingress_timestamp.ingress_timestamp))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_ingress_timestamp.ingress_timestamp))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_ingress_timestamp.ingress_timestamp))[6];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 6, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_ingress_timestamp.ingress_timestamp))[7];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 7, (ebpf_byte));
            ebpf_packetOffsetInBits += 64;

        }
;        if (parsed_hdr->int_egress_timestamp.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 64)) {
                return TC_ACT_SHOT;
            }
            
            parsed_hdr->int_egress_timestamp.egress_timestamp = htonll(parsed_hdr->int_egress_timestamp.egress_timestamp);
            ebpf_byte = ((char*)(&parsed_hdr->int_egress_timestamp.egress_timestamp))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_egress_timestamp.egress_timestamp))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_egress_timestamp.egress_timestamp))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_egress_timestamp.egress_timestamp))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_egress_timestamp.egress_timestamp))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_egress_timestamp.egress_timestamp))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_egress_timestamp.egress_timestamp))[6];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 6, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_egress_timestamp.egress_timestamp))[7];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 7, (ebpf_byte));
            ebpf_packetOffsetInBits += 64;

        }
;        if (parsed_hdr->int_l2_interfaces.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 64)) {
                return TC_ACT_SHOT;
            }
            
            parsed_hdr->int_l2_interfaces.ingress_id = htonl(parsed_hdr->int_l2_interfaces.ingress_id);
            ebpf_byte = ((char*)(&parsed_hdr->int_l2_interfaces.ingress_id))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_l2_interfaces.ingress_id))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_l2_interfaces.ingress_id))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_l2_interfaces.ingress_id))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

            parsed_hdr->int_l2_interfaces.egress_id = htonl(parsed_hdr->int_l2_interfaces.egress_id);
            ebpf_byte = ((char*)(&parsed_hdr->int_l2_interfaces.egress_id))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_l2_interfaces.egress_id))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_l2_interfaces.egress_id))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_l2_interfaces.egress_id))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

        }
;        if (parsed_hdr->int_egress_tx.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 32)) {
                return TC_ACT_SHOT;
            }
            
            parsed_hdr->int_egress_tx.egress_tx_utilization = htonl(parsed_hdr->int_egress_tx.egress_tx_utilization);
            ebpf_byte = ((char*)(&parsed_hdr->int_egress_tx.egress_tx_utilization))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_egress_tx.egress_tx_utilization))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_egress_tx.egress_tx_utilization))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_egress_tx.egress_tx_utilization))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

        }
;        if (parsed_hdr->int_buffer_info.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 32)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&parsed_hdr->int_buffer_info.buffer_id))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr->int_buffer_info.buffer_occupancy = htonl(parsed_hdr->int_buffer_info.buffer_occupancy << 8);
            ebpf_byte = ((char*)(&parsed_hdr->int_buffer_info.buffer_occupancy))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_buffer_info.buffer_occupancy))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_buffer_info.buffer_occupancy))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_packetOffsetInBits += 24;

        }
;        if (parsed_hdr->int_checksum.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 32)) {
                return TC_ACT_SHOT;
            }
            
            parsed_hdr->int_checksum.checksum = htonl(parsed_hdr->int_checksum.checksum);
            ebpf_byte = ((char*)(&parsed_hdr->int_checksum.checksum))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_checksum.checksum))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_checksum.checksum))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_checksum.checksum))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

        }
;        if (parsed_hdr->int_data.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 128)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[6];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 6, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[7];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 7, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[8];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 8, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[9];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 9, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[10];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 10, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[11];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 11, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[12];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 12, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[13];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 13, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[14];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 14, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr->int_data.metadata_stack))[15];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 15, (ebpf_byte));
            ebpf_packetOffsetInBits += 128;

        }
;
    }
    if (ostd.clone) {
        do_packet_clones(skb, &clone_session_tbl, ostd.clone_session_id, CLONE_E2E, 3);
    }

    if (ostd.drop) {
        return TC_ACT_SHOT;;
    }

    if (istd.egress_port == P4C_PSA_PORT_RECIRCULATE) {
        compiler_meta__->packet_path = RECIRCULATE;
        return bpf_redirect(PSA_PORT_RECIRCULATE, BPF_F_INGRESS);
    }

    
    return TC_ACT_OK;
}
char _license[] SEC("license") = "GPL";
